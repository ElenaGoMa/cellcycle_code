---
title: "enhancers"
format: html
editor: visual
---

February 2025

## Enhancer calling

I use quickenhancers function from CAGEfightR package because CAGEr's function for enhancer calling does not work. I used the cager object generated by CAGEr to which I had to add seqlength (chromosome length), as required by quickenhancers. I tried quickenhancers from different stages of analysis (CAGEexp from CTSS, consensus cluster, low or high TPM threshold) and I always get the same result on called enhancers. quickenhancers gives ranges of enhancers and raw counts mapping at each enhancers, I use these ranges to extract the normalised counts from my CAGEexp for calling introns (low tpm threshold)

```{r}
# from CAGEconsprom scripts
# saveRDS(tmp_2, "/Users/egomezma/Desktop/cellcycle/R/splitted_scripts/1_CAGEconsprom/ce_canChr.rds")
# saveRDS(newCAGE_cchr_samples_filt, "/Users/egomezma/Desktop/cellcycle/R/splitted_scripts/1_CAGEconsprom/newCAGE_cchr_samples_filt.rds")
# saveRDS(newCAGE_mergRep, "/Users/egomezma/Desktop/cellcycle/R/splitted_scripts/1_CAGEconsprom/newCAGE_unnorm.rds")
# saveRDS(CTSS_norm, "/Users/egomezma/Desktop/cellcycle/R/splitted_scripts/1_CAGEconsprom/CTSS_norm.rds")
# saveRDS(CTSS_cluster, "/Users/egomezma/Desktop/cellcycle/R/splitted_scripts/1_CAGEconsprom/newCAGE_CTSS_promwidth.rds")
# saveRDS(cons_cluster, "/Users/egomezma/Desktop/cellcycle/R/splitted_scripts/1_CAGEconsprom/newCAGE_consclust_5tpm.rds")

# from promoters script
# saveRDS(totalSOM_consclusterGR_df, "/Users/egomezma/Desktop/cellcycle/R/splitted_scripts/2_promoters/totalSOM_consclusterGR_df.rds")
# saveRDS(nuclearSOM_consclusterGR_df, "/Users/egomezma/Desktop/cellcycle/R/splitted_scripts/2_promoters/nuclearSOM_consclusterGR_df.rds")
# saveRDS(fractionSOM_consclusterGR_df, "/Users/egomezma/Desktop/cellcycle/R/splitted_scripts/2_promoters/fractionSOM_consclusterGR_df.rds")


# from introns script
# saveRDS(cluster_lowthr_prom, "/Users/egomezma/Desktop/cellcycle/R/splitted_scripts/3_introns/cluster_lowthr_prom.rds")
# saveRDS(transcript_data, file = "~/Desktop/cellcycle/R/splitted_scripts/3_introns/transcript_data.rds")
# saveRDS(intronID_tsl1, "/Users/egomezma/Desktop/cellcycle/R/splitted_scripts/3_introns/intronID_tsl1.rds")
# saveRDS(tM_intronSignal_good_unique, "~/Desktop/cellcycle/R/splitted_scripts/3_introns/tM_intronSignal_good_unique.rds")
# saveRDS(M_intronSignal_prom_ensembl, "~/Desktop/cellcycle/R/splitted_scripts/3_introns/M_intronSignal_prom_ensembl.rds")

# from enhancers script
# saveRDS(enh, "~/Desktop/cellcycle/R/splitted_scripts/4_enhancers/enh.rds")
# saveRDS(enh_tpm, "~/Desktop/cellcycle/R/splitted_scripts/4_enhancers/enh_tpm.rds")
# saveRDS(enh_tpm, "~/Desktop/cellcycle/R/splitted_scripts/4_enhancers/enh_tpm_overlap.rds")
# saveRDS(enh_bothstr_ranges_df, "~/Desktop/cellcycle/R/splitted_scripts/4_enhancers/enh_bothstr_ranges_df.rds")
# saveRDS(enh_strongF, "~/Desktop/cellcycle/R/splitted_scripts/4_enhancers/enh_strongF.rds")
# saveDb(txdb.ensembl, file = "~/Desktop/cellcycle/R/splitted_scripts/4_enhancers/txdb.ensembl.db")


# saveRDS(enh_stronF_wo_nM, file = "~/Desktop/cellcycle/R/splitted_scripts/4_enhancers/enh_noTSS/enh_stronF_wo_nM.rds")
# saveRDS(enh_stronF_noTSS, "~/Desktop/cellcycle/R/splitted_scripts/4_enhancers/enh_noTSS/enh_stronF_noTSS.rds")

enh_tpm = readRDS("~/Desktop/cellcycle/R/splitted_scripts/4_enhancers/enh_tpm_overlap.rds")
enh_strongF = readRDS("~/Desktop/cellcycle/R/splitted_scripts/4_enhancers/enh_strongF.rds")
txdb.ensembl = loadDb("~/Desktop/cellcycle/R/splitted_scripts/4_enhancers/txdb.ensembl.db")
enh_stronF_noprom_SOM = readRDS("~/Desktop/cellcycle/R/splitted_scripts/4_enhancers/enh_stronF_noprom_SOM.rds")
enh_stronF_wo_nM = readRDS("~/Desktop/cellcycle/R/splitted_scripts/4_enhancers/enh_noTSS/enh_stronF_wo_nM.rds")



```

```{r}

library(BSgenome.Hsapiens.UCSC.hg38)
library(plyranges)
library(CAGEr)
library(tidyr)
library(dplyr)
library(ggplot2)
library(tidyverse)

```




Call enhancers and assign tpm signal from normalised CTSSs

```{r}
library(CAGEfightR)
library(BSgenome.Hsapiens.UCSC.hg38)
#BiocManager::install("plyranges")
library(plyranges)
library(CAGEr)

CTSS_cluster = readRDS("/Users/egomezma/Desktop/cellcycle/R/splitted_scripts/1_CAGEconsprom/newCAGE_CTSS_promwidth.rds")
cluster_lowthr_prom = readRDS("/Users/egomezma/Desktop/cellcycle/R/splitted_scripts/3_introns/cluster_lowthr_prom.rds")

# I include chromosome seqlengths to the cager object because quickEnhancers requires it
seqlengths(rowRanges(CTSStagCountSE(CTSS_cluster))) <- seqlengths(BSgenome.Hsapiens.UCSC.hg38)[1:23]
seqlengths(rowRanges(CTSStagCountSE(cluster_lowthr_prom))) <- seqlengths(BSgenome.Hsapiens.UCSC.hg38)[1:23]
# I specify chromosomes 1:23 that are the ones I have in my cagexp (BSgenome has many more)
seqlevels(rowRanges(CTSStagCountSE(CTSS_cluster)))
seqlengths(rowRanges(CTSStagCountSE(CTSS_cluster)))

enh = quickEnhancers(CTSS_cluster)
# saveRDS(enh, "~/Desktop/cellcycle/R/splitted_scripts/4_enhancers/enh.rds")
enh = readRDS("~/Desktop/cellcycle/R/splitted_scripts/4_enhancers/enh.rds")
#enh_conclu = quickEnhancers(cons_cluster) # calling enhancers from CTSS_cluster or cons_cluster cage objects gives the same result.
#enh_conclu = quickEnhancers(cluster_lowthr_prom) # calling enhancers from low threshold TPM cage object gives the same result.


enh_gr = GRanges(rownames(assays(enh)$enhancers)) # granges of the enhancers
enh_gr_df = as.data.frame(enh_gr)
rowRanges(assays(enh)$enhancers) # retrieves two columns and no idea what it is
rownames(assays(enh)$enhancers) # retrieves rownames that assay that are enhancers coordinates
enh_rawcounts = assays(enh)$enhancers # retrieves rawcounts per sample mapping at each enhancer. USEFUL!



# enh_gr
# cluster_lowthr_prom

# Extract normalized CTSS (CAGE Transcription Start Site) counts
tss_counts <- CTSStagCountSE(cluster_lowthr_prom)  # SummarizedExperiment object
tss_gr <- rowRanges(tss_counts)  # Get GRanges object for TSS

# Extract normalized count matrix
norm_counts <- as.data.frame(assay(tss_counts, "normalizedTpmMatrix"))
# Find which TSS sites overlap with enhancers
overlaps <- findOverlaps(enh_gr, tss_gr)  # Query = enhancers, Subject = TSS
# Sum normalized counts of overlapping TSS per enhancer
enh_tpm_raw <- rowsum(norm_counts[overlaps@to, ], group = overlaps@from)



enh_tpm <- enh_tpm_raw %>%
  mutate(sum_nuclear = rowSums(enh_tpm_raw[,1:5])) %>%
  mutate(sum_total = rowSums(enh_tpm_raw[,6:10])) %>%
  mutate(nucl_tot = sum_nuclear>sum_total) %>% # 23008 enhancers have higher signal in nuclear than total (out of 34174)
  mutate(seqnames = enh_gr_df$seqnames,
         start = enh_gr_df$start,
         end = enh_gr_df$end,
         strand = enh_gr_df$strand) %>%
  # filter(!(sum_nuclear == 0 & sum_total == 0)) %>%
  rowwise() %>%  # Process each row individually
  mutate(sum_samplesTot = sum(c_across(6:10) > 0.0001),
         median_tot = sum_total/sum_samplesTot,
         sum_samplesNuc = sum(c_across(1:5) > 0.0001),
         median_nuc = sum_nuclear/sum_samplesNuc) %>%
  ungroup() %>%
  mutate(median_tot = ifelse(is.na(median_tot), 0, median_tot),
         median_nuc = ifelse(is.na(median_nuc), 0 , median_nuc))

 


# subset_norm_counts_GR = GRanges(seqnames = enh_tpm$seqnames,
#                                 ranges = IRanges(start = enh_tpm$start,
#                                         end = enh_tpm$end)) # THIS IS ENH_GR

# saveRDS(enh_tpm, "~/Desktop/cellcycle/R/splitted_scripts/4_enhancers/enh_tpm.rds")

# subset_norm_counts <- subset_norm_counts %>%
#   mutate(sum_nuclear = rowSums(subset_norm_counts[,1:5])) %>%
#   mutate(sum_total = rowSums(subset_norm_counts[,6:10])) %>%
#   mutate(nucl_tot = sum_nuclear>sum_total) %>% # 23008 enhancers have higher signal in nuclear than total (out of 34174)
#   mutate(seqnames = enh_rawcounts_df$seqnames,
#          start = enh_rawcounts_df$start,
#          end = enh_rawcounts_df$end,
#          strand = enh_rawcounts_df$strand)
# subset_norm_counts_GR = GRanges(seqnames = subset_norm_counts$seqnames,
#                                 ranges = IRanges(start = subset_norm_counts$start,
#                                         end = subset_norm_counts$end))
```

## overlp encode prom/enh

```{r}
library(tidyr)

## Encode promoter annotation to filter out enhancers mapping there
# https://screen.encodeproject.org/
# Downloads - candidate promoters (hg38)

encode_promoters = read.table("~/Desktop/cellcycle/encode/encode_promoters_GRCh38.bed",
                              header = F,
                              sep = "\t",
                              stringsAsFactors = F,
                              colClasses = c("factor", "integer", "integer", "character", "character", "character"))
encode_enhancers = read.table("~/Desktop/cellcycle/encode/encode_enhancers_GRCh38.bed",
                              header = F,
                              sep = "\t",
                              stringsAsFactors = F,
                              colClasses = c("factor", "integer", "integer", "character", "character", "character"))


encode_promoters_gr = GRanges(seqnames = encode_promoters$V1,
                              ranges = IRanges(start = encode_promoters$V2,
                                      end = encode_promoters$V3))
# enh_nonprom_gr = enh_gr[!overlapsAny(enh_gr, encode_promoters_gr)]
encode_enhancers_gr = GRanges(seqnames = encode_enhancers$V1,
                              ranges = IRanges(start = encode_enhancers$V2,
                                               end = encode_enhancers$V3,
                                               enhancerID = encode_enhancers$V5,
                                               enhancer_annot = encode_enhancers$V6))
# enh_filt_gr = enh_nonprom_gr[overlapsAny(enh_nonprom_gr, encode_enhancers_gr)]
# enh_noprom_noenh = enh_nonprom_gr[!overlapsAny(enh_nonprom_gr, encode_enhancers_gr)]


## assign enhancers that overlap with encode promoters. 2790 detected enhancers overlaps with encode enhancers (out of 34174)
overlaps_encode_prom = findOverlaps(enh_gr, encode_promoters_gr)
valid_indices <- queryHits(overlaps_encode_prom) # I had to do this because there might be duplicated or unexpected indices that flagged wrongly
valid_indices <- valid_indices[valid_indices <= nrow(enh_tpm)]  # Filter valid indices
enh_tpm$overlap_encode_prom <- FALSE  # Default
enh_tpm$overlap_encode_prom[valid_indices] <- TRUE  # Assign TRUE only to valid rows

## assign enhancers that overlap with encode enhancers. 16583 detected enhancers overlaps with encode enhancers (out of 34174)
overlaps_encode_enh = findOverlaps(enh_gr, encode_enhancers_gr)
enh_tpm$overlap_encode_enhancers <- FALSE  # Default
enh_tpm$overlap_encode_enhancers[queryHits(overlaps_encode_enh)] <- TRUE  # Assign TRUE only to valid rows

# saveRDS(enh_tpm, "~/Desktop/cellcycle/R/splitted_scripts/4_enhancers/enh_tpm_overlap.rds")
# enh_tpm = readRDS("~/Desktop/cellcycle/R/splitted_scripts/4_enhancers/enh_tpm_overlap.rds")
```


Count overlapping promoters or enhancers
```{r}
enh_tpm_Hnuclear = enh_tpm[which(enh_tpm$nucl_tot == T),]
enh_tpm_Htotal = enh_tpm[which(enh_tpm$nucl_tot == F),]

df_long2 <- pivot_longer(enh_tpm_Hnuclear, cols = c(overlap_encode_prom, overlap_encode_enhancers), names_to = "Category", values_to = "Value")

# Count occurrences of TRUE and FALSE
df_count <- as.data.frame(table(df_long2$Category, df_long2$Value))
colnames(df_count) <- c("Category", "Value", "Freq")

# Customize labels
df_count$Label <- paste(df_count$Category, df_count$Value, sep = " - ")

# Plot the histogram
ggplot(df_count, aes(x = Label, y = Freq, fill = Value)) +
  geom_bar(stat = "identity") +
  labs(title = "Enhancers with higher score in nuclear vs total RNA (23,008)", x = "Groups", y = "Count") +
  scale_fill_manual(values = c("TRUE" = "blue", "FALSE" = "red")) +
  theme_minimal()

```



## Filter strand and replicate wise

```{r}
# Load necessary library
library(rtracklayer)

# Define a vector with the paths of the BigWig files
bw_files_plus <- list.files(path = "~/Desktop/cellcycle/CAGE_nfpipeline/unmapped_10places/bigwig/", pattern = ".str1.out.wig.bw$", full.names = TRUE)
bw_files_minus <- list.files(path = "~/Desktop/cellcycle/CAGE_nfpipeline/unmapped_10places/bigwig/", pattern = ".str2.out.wig.bw$", full.names = TRUE)

# Ensure both lists are sorted the same way
bw_files_plus <- sort(bw_files_plus)
bw_files_minus <- sort(bw_files_minus)

# Define a function to import BigWig files while assigning strand information
import_bw_with_strand <- function(file, strand) {
  gr <- import(file)    # Import BigWig as GRanges
  strand(gr) <- strand  # Assign strand information
  return(gr)
}

# Import plus-strand BigWigs and assign "+"
gr_list_plus <- lapply(bw_files_plus, import_bw_with_strand, strand = "+")

# Import minus-strand BigWigs and assign "-"
gr_list_minus <- lapply(bw_files_minus, import_bw_with_strand, strand = "-")

# Merge plus and minus strand GRanges per sample
gr_list_merged <- mapply(c, gr_list_plus, gr_list_minus, SIMPLIFY = FALSE)

# Assign names to the merged GRanges based on file names
names(gr_list_merged) <- gsub(".Signal.UniqueMultiple.str1.out.wig.bw", "", basename(bw_files_plus))

```

Split by replicate

```{r}
names <- c("nG0_rep1", "nG1_rep1", "nG2_rep1", "nS_rep1", "tG0_rep1", "tG1_rep1", "tG2_rep1", "tM_rep1", "tM_rep2", "tS_rep1", "nG1_rep2", "nG2_rep2", "nS_rep3", "nG0_rep3", "nG0_rep2", "nM_rep1", "nS_A_rep1", "nS_B_rep1", "nS_rep2", "nS_A_rep2", "nS_B_rep2",
           "tG0_rep2", "tG1_rep2", "tG2_rep2", "tS_rep2")
names(gr_list_merged) <- names
# Define replicate-specific lists
gr_list_rep1 <- gr_list_merged[grep("_rep1$", names(gr_list_merged))]
gr_list_rep2 <- gr_list_merged[grep("_rep2$", names(gr_list_merged))]
#gr_list_rep3 <- gr_list_merged[grep("_rep3$", names(gr_list_merged))]






# Initialize a logical matrix (default FALSE)
overlap_matrix_rep1 <- matrix(FALSE, nrow = length(enh_gr), ncol = length(gr_list_rep1))
overlap_matrix_rep2 <- matrix(FALSE, nrow = length(enh_gr), ncol = length(gr_list_rep2))
# Assign column names for clarity
# colnames(overlap_matrix_rep1) <- gsub("_rep1$", "", sort(names(gr_list_rep1)))
colnames(overlap_matrix_rep1) <- gsub("_rep1$", "", names(gr_list_rep1))
rownames(overlap_matrix_rep1) <- seq_len(length(enh_gr))
# colnames(overlap_matrix_rep2) <- gsub("_rep2$", "", sort(names(gr_list_rep2)))
colnames(overlap_matrix_rep2) <- gsub("_rep2$", "", names(gr_list_rep2))
rownames(overlap_matrix_rep2) <- seq_len(length(enh_gr))


# Function to check bidirectional overlap
check_bidirectional_overlap <- function(query, sample_gr) {
  # Find overlaps
  overlaps <- findOverlaps(query, sample_gr)
  
  # Get the strands of the overlapping regions
  query_strands <- strand(query)[queryHits(overlaps)] # not used?
  sample_strands <- strand(sample_gr)[subjectHits(overlaps)]
  
  # Check if each enhancer has overlaps from BOTH strands
  # bidirectional <- tapply(sample_strands, queryHits(overlaps), function(str) all(c("+" , "-") %in% unique(str)))
  
  overlap.enh.indexes = unique(sort(queryHits(overlaps)))
  bidirectional = unlist(lapply(1:length(query), # lapply returns a list, for vector as output use unlist
                                function(enh.index) {
                                  if (!enh.index %in% overlap.enh.indexes) {
                                    return(FALSE)
                                  }
                                  tss.indexes = overlaps[overlaps@from == enh.index]@to
                                  tss.strands = strand(sample_gr[tss.indexes])
                                  return(all(c("+", "-") %in% tss.strands))
                                }))
  
  # Convert named logical vector to full-length logical vector
  # bidirectional_full <- rep(FALSE, length(query))
  # bidirectional_full[as.numeric(names(bidirectional))] <- bidirectional
  
  # return(bidirectional_full)
  return(bidirectional)
}

# Populate the matrix with values of replicate1
for (i in seq_along(gr_list_rep1)) {
  # sample_name <- names(gr_list_rep1)[i] #not necessary?
  sample_gr <- gr_list_rep1[[i]]
  
  # Check for bidirectional overlap
  overlap_matrix_rep1[, i] <- check_bidirectional_overlap(enh_gr, sample_gr)
}


# Populate the matrix for replicate 2
for (i in seq_along(gr_list_rep2)) {
  sample_name <- names(gr_list_rep2)[i]
  sample_gr <- gr_list_rep2[[i]]
  
  # Check for bidirectional overlap
  overlap_matrix_rep2[, i] <- check_bidirectional_overlap(enh_gr, sample_gr)
}


# Create a new column with all TRUE values
new_column <- rep(TRUE, nrow(overlap_matrix_rep2))
# Convert matrix to dataframe to allow column insertion
overlap_matrix_rep2_df <- as.data.frame(overlap_matrix_rep2)
# Insert new column at position 10
overlap_matrix_rep2_df <- cbind(overlap_matrix_rep2_df, nM = new_column)
#overlap_matrix_rep2_df <- cbind(overlap_matrix_rep2_df[, 1:3], nM = new_column, overlap_matrix_rep2[, 4:ncol(overlap_matrix_rep2)])
overlap_matrix_rep2 <- as.matrix(overlap_matrix_rep2_df)
#reorder columns of matrix2
overlap_matrix_rep2_sort <- overlap_matrix_rep2[, match(colnames(overlap_matrix_rep1), colnames(overlap_matrix_rep2))]

# Update the matrix: TRUE only if TRUE in both replicates
final_overlap_matrix <- overlap_matrix_rep1 & overlap_matrix_rep2

```

Transfer values of overlap matrix to enhancers scores

```{r}
enh_tpm_raw
final_overlap_matrix
#Rename nM column as it is called in enh_tpm_raw df
colnames(final_overlap_matrix)[colnames(final_overlap_matrix) == "nM"] <- "nM_2"
#Reorder columns in matrix as in enh_tpm_raw df
final_overlap_matrix_sorted <- final_overlap_matrix[, match(colnames(enh_tpm_raw)[1:12], colnames(final_overlap_matrix))]


# Convert logical matrix to numeric (TRUE = 1, FALSE = 0)
mask <- as.matrix(final_overlap_matrix_sorted) * 1  

# Apply mask: set values to 0 where matrix has FALSE
enh_str_rep_fil = enh_tpm_raw[1:12]
enh_str_rep_fil[, 1:12] <- enh_str_rep_fil[, 1:12] * mask

# Add enhancers coordinates
enh_str_rep_fil = enh_str_rep_fil %>%
  mutate(seqnames = enh_gr_df$seqnames,
         start = enh_gr_df$start,
         end = enh_gr_df$end,
         strand = enh_gr_df$strand)

```

Find overlap with ENCODE annotated promoters and enhancers

```{r}


## assign enhancers that overlap with encode promoters. 2790 detected enhancers overlaps with encode enhancers (out of 34174)
overlaps_encode_prom = findOverlaps(enh_gr, encode_promoters_gr)
valid_indices <- queryHits(overlaps_encode_prom) # I had to do this because there might be duplicated or unexpected indices that flagged wrongly
valid_indices <- valid_indices[valid_indices <= nrow(enh_gr_df)]  # Filter valid indices
enh_str_rep_fil$overlap_encode_prom <- FALSE  # Default
enh_str_rep_fil$overlap_encode_prom[valid_indices] <- TRUE  # Assign TRUE only to valid rows

## assign enhancers that overlap with encode enhancers. 16583 detected enhancers overlaps with encode enhancers (out of 34174)
overlaps_encode_enh = findOverlaps(enh_gr, encode_enhancers_gr)
enh_str_rep_fil$overlap_encode_enhancers <- FALSE  # Default
enh_str_rep_fil$overlap_encode_enhancers[queryHits(overlaps_encode_enh)] <- TRUE  # Assign TRUE only to valid rows


saveRDS(enh_str_rep_fil, "~/Desktop/cellcycle/R/splitted_scripts/4_enhancers/enh_str_rep_fil.rds")

```


```{r}


# filter out enhancers with 0 values in both sum_nuclear and sum_total and those overlaping with encode promoters
enh_strongF = enh_str_rep_fil %>%
  mutate(sum_nuclear = rowSums(enh_str_rep_fil[,1:5])) %>%
  mutate(sum_total = rowSums(enh_str_rep_fil[,6:10])) %>%
  mutate(nucl_total = sum_nuclear - sum_total) %>%
  filter(!(sum_nuclear == 0 & sum_total == 0)) %>%
  filter(!(overlap_encode_prom == T)) %>%
  select(!overlap_encode_prom) %>%
  rowwise() %>%  # Process each row individually
  mutate(sum_samplesTot = sum(c_across(6:10) > 0.0001),
         median_tot = sum_total/sum_samplesTot,
         sum_samplesNuc = sum(c_across(1:5) > 0.0001),
         median_nuc = sum_nuclear/sum_samplesNuc) %>%
  ungroup() %>%
  mutate(median_tot = ifelse(is.na(median_tot), 0, median_tot),
         median_nuc = ifelse(is.na(median_nuc), 0 , median_nuc))
# filter out enhancers with tpm < 0.01 in at least one sample
enh_strongF <- enh_strongF[apply(enh_strongF[, 1:10], 1, function(x) any(x >= 0.01)), ]


  
# saveRDS(enh_strongF, "~/Desktop/cellcycle/R/splitted_scripts/4_enhancers/enh_strongF.rds")
# enh_strongF = readRDS("~/Desktop/cellcycle/R/splitted_scripts/4_enhancers/enh_strongF.rds")


```



## Differential nuclear total

```{r}

# Here the commented part did not work 

# apply_stat_test <- function(row) {
#   nuclear_values <- as.numeric(row[1:5])  # First 5 columns: nuclear RNA TPMs
#   total_values <- as.numeric(row[6:10])   # Next 5 columns: total RNA TPMs
#   
#   # Add a small pseudozero (1e-6) to avoid zero issues
#   nuclear_values[nuclear_values == 0] <- 1e-6
#   total_values[total_values == 0] <- 1e-6
#   
#   # Check if all values are the same (Wilcoxon is not valid in this case)
#   if (all(nuclear_values == total_values)) {
#     return(1)  # Return non-significant p-value if no variation
#   }
# 
#   # Perform Wilcoxon test with normal approximation
#   test_result <- wilcox.test(nuclear_values, total_values, 
#                              paired = TRUE,  # TRUE = Wilcoxon test; FALSE = Mann-Whitney test, better for small but consistent differences
#                              alternative = "two.sided",
#                              exact = FALSE)  # Force normal approximation
#   
#   return(test_result$p.value)  # Return the p-value
# }
# 
# # Apply function to each row
# enh_strongF$p_value <- apply(enh_strongF, 1, apply_stat_test)
# 
# # Adjust p-values for multiple testing (FDR correction)
# enh_strongF$adjusted_p_value <- p.adjust(enh_strongF$p_value, method = "BH")
# 
# enh_strongF$category <- ifelse(enh_strongF$adjusted_p_value < 0.05 & enh_strongF$nuclear_sum > enh_strongF$total_sum, "Higher in Nuclear",
#                         ifelse(enh_strongF$adjusted_p_value < 0.05 & enh_strongF$nuclear_sum < enh_strongF$total_sum, "Higher in Total",
#                                "Not Significant"))

# Plot correlation
library(dplyr)
df_tmp = enh_strongF %>%
  mutate(sum_nuclear = ifelse(sum_nuclear == 0, 1e-4, sum_nuclear),
         sum_total = ifelse(sum_total == 0, 1e-4, sum_total))

library(ggplot2)
correl = ggplot(df_tmp, aes(x = log10(sum_nuclear), y = log10(sum_total))) +
  geom_point(alpha = 0.5, color = "blue") +  # Scatter plot with transparency
  geom_smooth(method = "lm", color = "red", se = TRUE) +  # Linear regression line with confidence interval
  labs(title = "Correlation between Nuclear and Total RNA Sum",
       x = "Nuclear RNA Sum",
       y = "Total RNA Sum") +
  theme_minimal()


```



## enhancer scores

```{r}


## Boxplot enhancer scores

# subset_norm_counts_fil = subset_norm_counts %>%
#   filter(!(sum_nuclear == 0 & sum_total == 0))
# This filter is removing some enhancers that looks true just because nS_A or B have higher values
# subset_norm_counts_fil <- subset_norm_counts %>%
#   mutate(max = apply(select(., 1:10), 1, max)) %>%  # Create 'max' column with highest value from columns 1 to 10
#   filter(!(nS_A > max | nS_B > max))  # Remove rows where nS_A or nS_B is greater than 'max'


df_tmp = enh_strongF
df_tmp = enh_tpm


subet_norm_counts_Hnuclear = df_tmp[which(df_tmp$nucl_total > 0),]
subet_norm_counts_Hnuclear = subet_norm_counts_Hnuclear %>%
  mutate(sum_nuclear = ifelse(sum_nuclear == 0, 1e-4, sum_nuclear)) %>%
  mutate(sum_total = ifelse(sum_total == 0, 1e-04, sum_total))
subet_norm_counts_Htotal = df_tmp[which(df_tmp$nucl_total < 0),]
subet_norm_counts_Htotal = subet_norm_counts_Htotal %>%
  mutate(sum_nuclear = ifelse(sum_nuclear == 0, 1e-4, sum_nuclear)) %>%
  mutate(sum_total = ifelse(sum_total == 0, 1e-04, sum_total))




df_long <- pivot_longer(subet_norm_counts_Htotal, cols = c(overlap_encode_enhancers), names_to = "Category", values_to = "Value")

df_long$Label <- paste(df_long$Category, df_long$Value, sep = " - ")

# Plot boxplot
ggplot(df_long, aes(x = Label, y = sum_nuclear, fill = Value)) +
  #geom_violin(trim = FALSE, alpha = 0.7) +  # Violin plot with transparency
  geom_point(alpha = 0.5, size = 0.5, color = "grey",
             position = position_jitter(width = 0.2)) +
  geom_boxplot(width = 0.4, outlier.shape = NA, alpha = 0.7) +  # Add boxplot inside
  labs(title = "Score of filtered enhancers (lower score in nuclear vs total)", x = "Groups", y = "sum_nuclear") +
  scale_y_log10(limits = c(1e-5, 1e+04)) +
  scale_fill_manual(values = c("TRUE" = "blue", "FALSE" = "red")) +
  theme_minimal()

  # scale_y_log10(limits = c(1e-5, 1e+05),
  #               breaks = c(1e-5, 1e-3, 1e-1, 1e+1, 1e+03, 1e+05)) +

```

```{r}
## Distribution of number of enhancers per group of NUCLEAR samples. Below for total samples


df_tmp = enh_strongF
# df_tmp = enh_tpm


df_count <- df_tmp %>%
  count(sum_samplesNuc)

p1 = ggplot(df_count, aes(x = sum_samplesNuc, y = n)) +
  geom_point(size = 3, color = "blue") +  # Dots with size 3 and blue color
  labs(title = "Distribution of enhancers per grouped samples (nuclear)",
       x = "Number of samples",
       y = "Number of enhancers") +
  scale_y_continuous(limits = c(100, 1600)) +
  theme_minimal()
# limits = c(400, 10000),
#        breaks = c(0, 2000, 4000, 6000, 8000, 10000)

## Distribution of score of enhancers per group of nuclear samples
p2 = ggplot(df_tmp, aes(x = factor(sum_samplesNuc), y = median_nuc)) +
  geom_boxplot(outlier.alpha = 0.5) +  # Boxplot with slightly transparent outliers
  labs(title = "Distribution of sum_nuclear per grouped samples (nuclear)",
       x = "grouped nuclear samples",
       y = "sum_nuclear/nsamples") +
  scale_y_log10(limits = c(1e-3, 1e+02),
                breaks = c(1e-3, 1e-2, 1e-1, 1, 1e+1, 1e+02)) +
  theme_minimal()

```

```{r}
####
## Distribution of number of enhancers per group of TOTAL samples

# enh_tpm <- enh_tpm %>%
  # rowwise() %>%  # Process each row individually
  # mutate(sum_samplesTot = sum(c_across(6:10) > 0.0001)) %>%
  # mutate(median_tot = sum_total/sum_samplesTot) %>%
  # ungroup()

df_tmp = enh_strongF
# df_tmp = enh_tpm


df_count <- df_tmp %>%
  count(sum_samplesTot)

p3 = ggplot(df_count, aes(x = sum_samplesTot, y = n)) +
  geom_point(size = 3, color = "blue") +  # Dots with size 3 and blue color
  labs(title = "Distribution of enhancers per grouped samples (total)",
       x = "Number of samples",
       y = "Number of enhancers") +
  scale_y_continuous(limits = c(100, 1600)) +
  theme_minimal()

## Distribution of score of enhancers per group of nuclear samples
p4 = ggplot(df_tmp, aes(x = factor(sum_samplesTot), y = median_tot)) +
  geom_boxplot(outlier.alpha = 0.5) +  # Boxplot with slightly transparent outliers
  labs(title = "Distribution of sum_total per grouped samples (total)",
       x = "grouped total samples",
       y = "sum_total/nsamples") +
  scale_y_log10(limits = c(1e-3, 1e+02),
                breaks = c(1e-3, 1e-2, 1e-1, 1, 1e+1, 1e+02)) +
  theme_minimal()


```

```{r}
# Distribution of enhancer score per sample
enh_strongF
# enh_tpm

df_long <- enh_strongF %>%
  select(1:10) %>%
  pivot_longer(cols = everything(), names_to = "Variable", values_to = "Value") %>%
  mutate(Value = ifelse(Value == 0, 1e-4, Value)) %>%
  filter(Value > 1e-4)
  
p5 = ggplot(df_long, aes(x = factor(Variable, levels = unique(Variable)), y = Value)) +
  geom_boxplot(outlier.alpha = 0.5) +  # Boxplot with slightly transparent outliers
  labs(title = "Signal of filtered enhancer",
       x = "Samples",
       y = "tpm values (log scaled)") +
  scale_y_log10(limits = c(1e-03, 1e+3),
                breaks = c(1e-3, 1e-2, 1, 1e+2, 1e+3)) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))  # Rotate x labels



# number of enhancers with signal > 0.0001 per sample
# df_tmp
# enh_strongF

df_counts <- enh_strongF %>%
  summarise(across(1:10, ~ sum(. > 0))) %>%  # Count rows > 0.0001 per column
  pivot_longer(cols = everything(), names_to = "Column", values_to = "Count")  # Reshape for ggplot

# Plot as dot plot
p6 = ggplot(df_counts, aes(x = factor(Column, levels = unique(Column)), y = Count)) +
  geom_point(size = 3, color = "blue") +  # Dots with size 3 and blue color
  labs(title = "Filtered enhancers tpm > 0 per sample",
       x = "Samples",
       y = "Count of Rows > 0") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))  # Rot

```




## Filter noTSS

```{r}
# Filter out detected enhancers overlapping promoters

# CREATE ENSEMBL TXDB
library(TxDb.Hsapiens.UCSC.hg38.knownGene)
txdb<-TxDb.Hsapiens.UCSC.hg38.knownGene
txdb.ensembl = txdbmaker::makeTxDbFromGFF(file = "~/Desktop/reference_genome/ENSEMBL/Homo_sapiens.GRCh38.113.gtf",format = "gtf",
                               dataSource = "https://ftp.ensembl.org/pub/release-113/gtf/homo_sapiens/",
                               organism = "Homo sapiens")
#seqlevels(txdb.ensembl) is 1, 2 (instead of chr1, chr2). Here is how I changed it and removed non canonical chr
newSeqNames <- paste('chr', seqlevels(txdb.ensembl), sep = '')
names(newSeqNames) <- seqlevels(txdb.ensembl)
txdb.ensembl <- renameSeqlevels(txdb.ensembl, newSeqNames)
keepSeqlevels(x = txdb.ensembl,value = seqlevels(txdb.ensembl)[1:24]) # keep canonical chromosomes
seqlevels(txdb.ensembl) # to check sequence levels
#
# saveDb(txdb.ensembl, file = "~/Desktop/cellcycle/R/splitted_scripts/4_enhancers/txdb.ensembl.db")
# txdb.ensembl = loadDb("~/Desktop/cellcycle/R/splitted_scripts/4_enhancers/txdb.ensembl.db")

library(ChIPseeker)

# annotate all enhancers
enh_tpm_GR = GRanges(seqnames = enh_tpm$seqnames,
                     ranges = IRanges(start = enh_tpm$start,
                                      end = enh_tpm$end), 
                                      strand = enh_tpm$strand)

annotated_enhancers = annotatePeak(enh_tpm_GR, 
                                   TxDb = txdb.ensembl, 
                                   tssRegion = c(-500, 200))
annotated_enhancers_df = as.data.frame(annotated_enhancers@anno)

enh_tpm = enh_tpm %>%
  mutate(distanceToTSS = annotated_enhancers_df$distanceToTSS,
         geneStrand = annotated_enhancers_df$geneStrand,
         geneId = annotated_enhancers_df$geneId)

# annotate filterd enhancers
enh_strongF_GR = GRanges(seqnames = enh_strongF$seqnames,
                     ranges = IRanges(start = enh_strongF$start,
                                      end = enh_strongF$end), 
                                      strand = enh_strongF$strand)

annotated_enh_strongF = annotatePeak(enh_strongF_GR, 
                                   TxDb = txdb.ensembl, 
                                   tssRegion = c(-500, 200))
annotated_enh_strongF_df = as.data.frame(annotated_enh_strongF@anno)

enh_strongF = enh_strongF %>%
  mutate(distanceToTSS = annotated_enh_strongF_df$distanceToTSS,
         geneStrand = annotated_enh_strongF_df$geneStrand,
         geneId = annotated_enh_strongF_df$geneId)

enh_stronF_noTSS = enh_strongF[which(!enh_strongF$distanceToTSS == 0),]


# saveRDS(enh_stronF_noTSS, "~/Desktop/cellcycle/R/splitted_scripts/4_enhancers/enh_noTSS/enh_stronF_noTSS.rds")

```

```{r}


#correlation distance to promoter vs sum/nsamples

# enh_tpm
# enh_strongF


# df_tmp = enh_tpm %>%
#   mutate(distanceToTSS = ifelse(distanceToTSS == 0, 0.1, distanceToTSS),
#          overlaps = ifelse(overlap_encode_prom == T, "prom", overlap_encode_enhancers),
#          overlaps = ifelse(overlaps == T, "enh", overlaps),
#          overlaps = ifelse(overlaps == "prom" & overlap_encode_enhancers == T, "prom_enh", overlaps),
#          median_nuc = ifelse(is.na(median_nuc), 1e-3, median_nuc),
#          median_tot = ifelse(is.na(median_tot), 1e-3, median_tot))
#df_tmp$overlaps = as.factor(df_tmp$overlaps)



library(ggplot2)

enh_stronF_noTSS
# enh_strongF

df_tmp = enh_stronF_noTSS %>%
  mutate(distanceToTSS = ifelse(distanceToTSS == 0, 0.1, distanceToTSS),
         median_nuc = ifelse(is.na(median_nuc), 1e-3, median_nuc),
         median_tot = ifelse(is.na(median_tot), 1e-3, median_tot),
         median_nuc = ifelse(median_nuc == 0, 1e-3, median_nuc),
         median_tot = ifelse(median_tot == 0, 1e-3, median_tot))

# df_tmp_enh = df_tmp[which(df_tmp$overlaps == "enh"),]
# df_tmp_prom = df_tmp[which(df_tmp$overlaps == "prom"),]
# df_tmp_promenh = df_tmp[which(df_tmp$overlaps == "prom_enh"),]
# df_tmp_F = df_tmp[which(df_tmp$overlaps == "FALSE"),]

df_tmp_F = df_tmp[which(df_tmp$overlap_encode_enhancers == "FALSE"),]
df_tmp_T = df_tmp[which(df_tmp$overlap_encode_enhancers == "TRUE"),]



p7 = ggplot(df_tmp_T, aes(x = abs(distanceToTSS), y = median_nuc)) +
  geom_bin2d(bins = 60) +  # Uses rectangular bins instead of contours
  scale_x_log10(limits = c(1e-2, 1e+6)) +  
  scale_y_log10(limits = c(1e-4, 1e+3)) +  
  scale_fill_viridis_c() +  # Gradient color for density
  labs(title = "Overlapping ensembl-enhancers",
       x = "Distance to TSS (log10, absolute)",
       y = "NuclearSum/nSamples Signal (log10)") +
  theme_minimal()
p8 = ggplot(df_tmp_T, aes(x = abs(distanceToTSS), y = median_tot)) +
  geom_bin2d(bins = 60) +  # Uses rectangular bins instead of contours
  scale_x_log10(limits = c(1e-2, 1e+6)) +  
  scale_y_log10(limits = c(1e-4, 1e+3)) +  
  scale_fill_viridis_c() +  # Gradient color for density
  labs(title = "Overlapping ensembl-enhancers",
       x = "Distance to TSS (log10, absolute)",
       y = "TotalSum/nSamples Signal (log10)") +
  theme_minimal()



```

## HEATMAP

```{r}
library(ComplexHeatmap)
library(circlize)

# enh_tpm
# enh_strongF
# enh_stronF_noTSS

# Select only the first 5 columns with enhancer expression scores
heatmap_data <- enh_stronF_noTSS[, 1:4]

# Apply log10 transformation (adding a small pseudo-count to avoid log(0) issues)
heatmap_data_log <- log10(heatmap_data + 1e-4)  # Small pseudo-count to avoid -Inf

# Define color mapping: blue for low, white for medium, red for high expression
col_fun <- colorRamp2(c(min(heatmap_data_log), 0, max(heatmap_data_log)), c("blue", "white", "red"))

# Create heatmap with hierarchical clustering of rows
p9 = Heatmap(heatmap_data_log,
        name = "Log10(Expression)",  # Legend title
        col = col_fun,  # Color scale
        cluster_rows = TRUE,  # Hierarchical clustering of enhancers
        cluster_columns = FALSE,  # Keep conditions in fixed order
        show_row_names = FALSE,  # Hide enhancer names if too many
        show_column_names = TRUE,  # Show condition names
        row_dend_reorder = TRUE,  # Reorder rows based on hierarchical clustering
        column_title = "Enhancer Expression (Log10) Across Conditions",
        heatmap_legend_param = list(title = "Log10(Relative Expression)"))


```




## SOM

```{r}

library(kohonen)
library(tidyverse)
library(rtracklayer)
library(dplyr)

# enh_stronF_noTSS
# enh_stronF_noTSS_SOM

## any palette
colors_magma <- viridisLite::magma(9)


get_plot_som_colors <- function(in_mat, xdim, ydim){
  my_palette <- colors_magma
  som_obj <- kohonen::som(in_mat,
                          grid = somgrid(xdim, ydim, topo = "hexagonal"))
  label_unit <- table(som_obj$unit.classif)
  tmp_name <- names(label_unit)
  label_unit <- str_c("Class ", tmp_name, " (", label_unit, ")")
  names(label_unit) <- tmp_name
  tmp_df <- in_mat %>% as.data.frame() %>%
    {cbind(class = som_obj$unit.classif, .)} %>%
    pivot_longer(cols = !class,
                 names_to = "stage",
                 values_to = "value") %>%
    mutate(stage = factor(stage,
                          levels = colnames(in_mat)),
           class = factor(class,
                          levels = str_sort(unique(class), numeric = T)))
  sum_stat <- tmp_df %>% group_by(class, stage) %>%
    summarize(value = mean(value)) %>% ungroup()
  out_plot <- tmp_df%>%
    ggplot(aes(stage, value, fill = stage)) + geom_violin() +
    geom_point(data = sum_stat) +
    geom_line(data = sum_stat, aes(group = class)) +
    facet_wrap(~ class, ncol = xdim, labeller = labeller(class = label_unit),
               scale = "free_y",as.table = F) +
    theme_light() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
    scale_fill_manual(values = my_palette)
  list(som = som_obj,
       stat = sum_stat,
       plot = out_plot)
}




enh_stronF_noTSS_wo_nM = enh_stronF_noTSS[-5]
# remove rows with value 0 in all columns
enh_stronF_noTSS_wo_nM = enh_stronF_noTSS_wo_nM[rowSums(enh_stronF_noTSS_wo_nM[, 1:9]) != 0, ]

nEnh_matrix = enh_stronF_noTSS_wo_nM[,c(1:9)]
# remove rows with value 0 in all columns
nEnh_matrix <- nEnh_matrix[rowSums(nEnh_matrix != 0, na.rm = TRUE) > 0, ]
# scale matrix
nEnh_matrix = t(base::scale(t(nEnh_matrix), center = F, scale = TRUE))

set.seed(23)
plot_som_nEnh = get_plot_som_colors(nEnh_matrix, 5, 5)

enh_stronF_noTSS_wo_nM = enh_stronF_noTSS_wo_nM %>% cbind(as.data.frame(plot_som_nEnh$som$unit.classif))
colnames(enh_stronF_noTSS_wo_nM)[27] = "SOM"

saveRDS(enh_stronF_noTSS_wo_nM, file = "~/Desktop/cellcycle/R/splitted_scripts/4_enhancers/enh_stronF_noTSS_wo_nM.rds")

```


## Exp bed:all,SOM,sample

```{r}
# extract bed files per SOM class

# Get unique values in the SOM column
som_classes <- unique(enh_stronF_noTSS_wo_nM$SOM)

# Loop through each unique SOM class
for (som_class in som_classes) {
  # Filter rows belonging to the current SOM class
  bed_data <- enh_stronF_noTSS_wo_nM[enh_stronF_noTSS_wo_nM$SOM_wo_nM == som_class, c("seqnames", "start", "end", "strand")]
  
  # Define the output file name
  bed_file <- paste0("~/Desktop/cellcycle/plots/ELENA_CAGE_mergedRep/enhancers/strong_filter_noTSS/SOM_bed/class", som_class, ".bed")
  
  # Write to a BED file (without row names and quotes)
  write.table(bed_data, file = bed_file, sep = "\t", quote = FALSE, row.names = FALSE, col.names = FALSE)
}
```


```{r}
# extract in a single bed file all SOM to visualise in IGV SOM classes by numbers

# Define the output file
bed_file <- "~/Desktop/cellcycle/plots/ELENA_CAGE_mergedRep/enhancers/strong_filter_noTSS/SOM_bed/all_classes.bed"

# Select relevant columns and include SOM for coloring
bed_data <- enh_stronF_noTSS_wo_nM[, c("seqnames", "start", "end", "SOM")]

# Write to a single BED file
write.table(bed_data, file = bed_file, sep = "\t", quote = FALSE, row.names = FALSE, col.names = FALSE)
```

```{r}
# extract bed per sample

# Loop through sample columns (1 to 10)
for (i in 1:10) {
  sample_name <- colnames(enh_strongF)[i]  # Get sample name
  bed_data <- enh_strongF[enh_strongF[[i]] > 0, c("seqnames", "start", "end", "strand")]  # Filter rows where value > 0
  
  # Define the output file name
  bed_file <- paste0("~/Desktop/cellcycle/plots/ELENA_CAGE_mergedRep/enhancers/strong_filter_noTSS/bed_persample/", sample_name, ".bed")

  # Write to a BED file (without row names and quotes)
  write.table(bed_data, file = bed_file, sep = "\t", quote = FALSE, row.names = FALSE, col.names = FALSE)
}


```



## GO loop

```{r}

library(ggplot2)
library(clusterProfiler)
library("org.Hs.eg.db")
odb<-org.Hs.eg.db

# Get unique SOM values
som_classes <- unique(enh_stronF_noTSS_wo_nM$SOM)

# Directory to save results
output_dir <- "~/Desktop/cellcycle/plots/ELENA_CAGE_mergedRep/enhancers/strong_filter_noTSS/GO/"

# Loop through each unique SOM class
for (som_class in som_classes) {
  # Filter rows for the current SOM class
  eclass <- enh_stronF_noTSS_wo_nM[enh_stronF_noTSS_wo_nM$SOM == som_class, ]

  # Convert gene IDs
  S.df <- bitr(unique(eclass$geneId),
               fromType = "ENSEMBL",
               toType = "ENTREZID",
               OrgDb = odb)

  # Perform GO enrichment analysis
  S.ego <- enrichGO(gene = S.df$ENTREZID,
                    OrgDb = odb,
                    ont = "BP",
                    pvalueCutoff = 0.05,
                    pAdjustMethod = "BH",
                    qvalueCutoff = 0.1)

  # Generate GO enrichment plot
  num_enhancers <- nrow(eclass)
  S.ego.plot <- S.ego@result %>%
    arrange(p.adjust) %>% 
    head(20) %>%
    mutate(Description = factor(Description, levels = rev(Description))) %>%
    ggplot(aes(x = -log10(p.adjust), 
               y = Description,
               size = Count,
               colour = -log10(p.adjust))) +
      geom_point() +
      ggtitle(paste("Class", som_class, ";", num_enhancers, "enhancers")) +
      theme_classic() +
      theme(axis.text.y = element_text(size = 11))

  # Select the top 20 enriched GO terms
  top_n_GO <- S.ego@result[1:20, c("ID", "Description", "geneID")]

  # FUNCTION: Convert genes
  convert_genes <- function(gene_ids, from_type, to_type, orgdb) {
    bitr(gene_ids, fromType = from_type, toType = to_type, OrgDb = orgdb)
  }

  # Split geneIDs and convert to gene SYMBOLS
  GO_list <- lapply(top_n_GO$geneID, function(genes) {
    gene_vec <- unlist(strsplit(genes, "/"))  # Split by "/"
    converted <- convert_genes(gene_vec, "ENTREZID", "SYMBOL", odb)
    return(converted$SYMBOL)
  })

  # Find max number of genes in any category
  max_length <- max(sapply(GO_list, length))

  # Create a data frame with correct column names
  GO_df <- as.data.frame(do.call(cbind, lapply(GO_list, function(genes) c(genes, rep(NA, max_length - length(genes))))))
  colnames(GO_df) <- top_n_GO$Description  # Set correct column names

  # Define file paths
  table_path <- paste0(output_dir, "class", som_class, ".csv")
  plot_path <- paste0(output_dir, "class", som_class, ".png")

  # Save table
  write.table(GO_df, file = table_path, quote = FALSE, col.names = TRUE, row.names = FALSE, sep = "\t")

  # Save plot
  ggsave(plot_path, S.ego.plot, width = 9, height = 6)
}




```


## SOM TPM

```{r}
#enh_stronF_noTSS_wo_nM

ggplot(enh_stronF_noTSS_wo_nM, aes(x = factor(SOM), y = median_tot, fill = factor(SOM))) +
  geom_violin(trim = FALSE, alpha = 0.7) +        # Semi-transparent violin plot
  geom_jitter(width = 0.2, size = 0.1, alpha = 0.2) + # Jitter for individual points
  labs(x = "SOM", y = "Median of total signal (log10 scaled TPM)", fill = "Annotation") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) + # Rotate x-axis labels if needed
  ggtitle("Enhancer TPM of SOM Classes.") +
  scale_y_log10(limits = c(1e-3, 1e2),
                breaks = c(1e-3, 1e-2, 1e-1, 1, 1e1, 1e2)) # Set log10 scale


```


## enhancers vecinity
```{r}

enh_stronF_noTSS_wo_nM



# Sort the dataframe by genomic coordinates
enh_stronF_noTSS_wo_nM_sorted <- enh_stronF_noTSS_wo_nM[order(enh_stronF_noTSS_wo_nM$seqnames, enh_stronF_noTSS_wo_nM$start, enh_stronF_noTSS_wo_nM$end), ]

# Define shift function
shift_column <- function(vec, shift) {
  if (shift > 0) {
    return(c(rep(NA, shift), vec[1:(length(vec) - shift)]))  # Down shift
  } else if (shift < 0) {
    return(c(vec[(abs(shift) + 1):length(vec)], rep(NA, abs(shift))))  # Up shift
  } else {
    return(vec)  # No shift
  }
}

# Create new columns
for (i in c(5,4,3,2,1,-1,-2,-3,-4,-5)) {
  enh_stronF_noTSS_wo_nM_sorted[[as.character(i)]] <- shift_column(enh_stronF_noTSS_wo_nM_sorted$SOM, i)
}

colnames(enh_stronF_noTSS_wo_nM_sorted)[28:37] <- c("-5", "-4", "-3", "-2", "-1", "1", "2", "3", "4", "5")




# Add a new column "repetition" that counts occurrences of the SOM value in columns 28:37
enh_stronF_noTSS_wo_nM_sorted$repetition <- rowSums(enh_stronF_noTSS_wo_nM_sorted[, 28:37] == enh_stronF_noTSS_wo_nM_sorted$SOM, na.rm = TRUE)

# add columns called SOM1 to SOM25 and print the proportion of each enhancer class for each row
enh_vecinity = enh_stronF_noTSS_wo_nM_sorted

for (i in 1:25) {
  col_name <- paste0("SOM", i)  # Generate column name
  enh_vecinity[[col_name]] <- ifelse(rowSums(enh_vecinity[, 28:37] == i, na.rm = TRUE) == 0, 
                                                 0, 
                                                 rowSums(enh_vecinity[, 28:37] == i, na.rm = TRUE) / 10)
}


```



## Hist vecino

```{r}

output_dir <- "~/Desktop/cellcycle/plots/ELENA_CAGE_mergedRep/enhancers/strong_filter_noprom/strong_filter_noprom_nM/neighbour"
# Get unique SOM classes
som_classes <- sort(unique(enh_vecinity$SOM))

# Loop through each SOM class and generate/save a plot
for (som_class in som_classes) {
  
  # Filter for the current SOM class
  enh_vecinity_c <- enh_vecinity %>% filter(SOM == som_class)
  
  # Extract relevant columns (39:63) and compute column means
  enh_vecinity_c <- colMeans(enh_vecinity_c[, 39:63], na.rm = TRUE) %>% as.data.frame()
  colnames(enh_vecinity_c) <- "value"
  
  # Add SOM numbers and repetition counts
  enh_vecinity_c$SOM <- 1:25  # Ensure all SOM values from 1 to 25 are included
  enh_vecinity_c <- left_join(enh_vecinity_c, df_counts, by = "SOM") 
  
  # Compute normalized ratios
  enh_vecinity_c <- enh_vecinity_c %>% 
    mutate(class_freq = repetition / sum(repetition),
           somFreq_norm = value * class_freq,
           ratio = value / class_freq - 1)

  # Create the plot
  hist_vecino <- ggplot(enh_vecinity_c, aes(x = factor(SOM, levels = 1:25), y = ratio)) + 
    geom_bar(stat = "identity") +
    scale_y_continuous(limits = c(-0.5, 0.5)) +
    scale_x_discrete(breaks = 1:25) +  # Ensure all categories appear
    labs(title = paste("Class", som_class, "- Frequency of Neighbouring Classes of Enhancers"),
         x = "SOM Classes",
         y = "Normalized Frequency") +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1))

  # Save the plot as PNG
  ggsave(filename = paste0(output_dir, "/hist_vecino_", som_class, ".png"), 
         plot = hist_vecino, width = 8, height = 6, dpi = 300)
}

  
```




```{r}

enh_vec_region = enh_stronF_noTSS_wo_nM_sorted
library(GenomicRanges)
library(rtracklayer)
library(BSgenome.Hsapiens.UCSC.hg38)





# Convert to GenomicRanges object
enh_vec_region_gr <- GRanges(seqnames = enh_vec_region$seqnames,
                     ranges = IRanges(start = enh_vec_region$start, end = enh_vec_region$end),
                     strand = enh_vec_region$strand)
# Assign actual chromosome lengths
seqlengths(enh_vec_region_gr) <- seqlengths(BSgenome.Hsapiens.UCSC.hg38)[seqlevels(enh_vec_region_gr)]

# Find clusters of enhancers within 500kb 
clusters <- GenomicRanges::reduce(enh_vec_region_gr, min.gapwidth = 500000) 

# Assign cluster IDs
enh_vec_region$cluster <- findOverlaps(enh_vec_region_gr, clusters)@to

# Check clustered vs. isolated enhancers
table(bed$cluster)





cluster_counts <- enh_vec_region %>%
    count(cluster)

n_distribution <- cluster_counts %>%
  count(n)  # 'n' is how many times a cluster appears, second count() gives frequency

# Plot histogram
distrib = ggplot(n_distribution, aes(x = n, y = nn)) + 
  geom_bar(stat = "identity", fill = "steelblue") +
  labs(title = "Distribution of cluster sizes",
       x = "Cluster size",
       y = "Number of clusters") +
  theme_minimal()

cluster_counts <- cluster_counts %>%
  mutate(enh_size = case_when(
    n == 1 ~ "single",        # Appears once
    n >= 2 & n <= 5 ~ "small", # Appears 2-5 times
    n > 5 & n <= 24 ~ "big"    # Appears 6-24 times
  ))

# Merge classification back into enh_vec_region
enh_vec_region <- enh_vec_region %>%
  left_join(cluster_counts, by = "cluster")  # Adds the enh_size column



df_counts <- enh_vecinity %>%
  group_by(SOM) %>%
  summarise(repetition = n()) %>%
  ungroup() %>%
  mutate(class_freq = repetition / sum(repetition))


enh_vec_region_single = enh_vec_region[which(enh_vec_region$enh_size == "single"),]

count_single <- enh_vec_region_single %>%
  count(SOM) %>%
  complete(SOM = 1:25, fill = list(n = 0)) %>% # Ensures all SOMs exist, fills missing ones with n = 0
  cbind(df_counts)
count_single = count_single[-3]
count_single = count_single %>%
  mutate(freq = n*class_freq) %>%
  mutate(freq_single = n / sum(n))



enh_vec_region_small = enh_vec_region[which(enh_vec_region$enh_size == "small"),]

count_small <- enh_vec_region_small %>%
  count(SOM) %>%
  complete(SOM = 1:25, fill = list(n = 0)) %>% # Ensures all SOMs exist, fills missing ones with n = 0
  cbind(df_counts)
count_small = count_small[-3]
count_small = count_small %>%
  mutate(freq = n*class_freq) %>%
  mutate(freq_small = n / sum(n))


enh_vec_region_big = enh_vec_region[which(enh_vec_region$enh_size == "big"),]

count_big <- enh_vec_region_big %>%
  count(SOM) %>%
  complete(SOM = 1:25, fill = list(n = 0)) %>% # Ensures all SOMs exist, fills missing ones with n = 0
  cbind(df_counts)
count_big = count_big[-3]
count_big = count_big %>%
  mutate(freq = n*class_freq) %>%
  mutate(freq_big = n / sum(n))

distrib2 = ggplot(count_big, aes(x = SOM, y = freq)) + 
  geom_bar(stat = "identity", fill = "steelblue") +
  labs(title = "Distribution of cluster sizes",
       x = "Cluster size",
       y = "Number of clusters") +
  theme_minimal()


distrib2 <- ggplot(count_small, aes(x = factor(SOM, levels = 1:25), y = freq)) + 
    geom_bar(stat = "identity") +
    # scale_y_continuous(limits = c(-0.5, 0.5)) +
    scale_x_discrete(breaks = 1:25) +  # Ensure all categories appear
    labs(title = paste("Class", som_class, "- Frequency of Neighbouring Classes of Enhancers"),
         x = "SOM Classes",
         y = "Normalized Frequency") +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1))





library(ggplot2)
library(ggrepel)

# Scatter plot with labels
ggplot(count_big, aes(x = freq_big, y = class_freq, label = SOM)) +
  geom_point(color = "steelblue", alpha = 0.7, size = 2) +  # Smaller points
  geom_text_repel(size = 4, box.padding = 0.3, point.padding = 0.2) +  # Labels with repel
  labs(title = "Correlation Between freq_big and freq",
       x = "Frequency of Big Enhancers (freq_big)",
       y = "Frequency of All Enhancers (freq)") +
  theme_minimal()



ggplot(count_small, aes(x = freq_small, y = class_freq, label = SOM)) +
  geom_point(color = "steelblue", alpha = 0.7, size = 2) +  # Smaller dots
  geom_text_repel(size = 3, box.padding = 0.3, point.padding = 0.2) +  # Repelled labels
  geom_abline(slope = 1, intercept = 0, color = "black", linetype = "dashed", size = 0.5) +  # Fine x=y line
  scale_x_continuous(limits = c(0, 0.3)) +  # Set x-axis limit
  scale_y_continuous(limits = c(0, 0.3)) +  # Set y-axis limit
  labs(title = "Correlation between enhancer classes",
       x = "SOM Class Frequency of Small Cluster of Enhancers",
       y = "SOM Class Frequency of All Enhancers") +
  theme_minimal()
```


## BED clusters

```{r}

enh_vec_region <- enh_vec_region %>%
  group_by(cluster) %>% 
  mutate(cluster_start = first(start),  # First 'start' for each group
         cluster_end = last(end)) %>%      # Last 'end' for each group
  ungroup()

bed_clusters = enh_vec_region %>% dplyr::select(12,31,32,15) %>%
  unique()


# Define the output file
bed_file <- "~/Desktop/cellcycle/plots/ELENA_CAGE_mergedRep/enhancers/strong_filter_noprom/strong_filter_noprom_nM/enh_cluster/enh_clusters.bed"


# Write to a single BED file
write.table(bed_clusters, file = bed_file, sep = "\t", quote = FALSE, row.names = FALSE, col.names = FALSE)

```

## annot SOM enhancers

```{r}


enh_vec_region_gr <- GRanges(seqnames = enh_vec_region$seqnames,
                     ranges = IRanges(start = enh_vec_region$start, end = enh_vec_region$end),
                     strand = enh_vec_region$strand,
                     SOM = enh_vec_region$SOM)

enh_vec_region_ChIPseeker <- annotatePeak(enh_vec_region_gr,
                                          TxDb = txdb.ensembl,
                                          tssRegion = c(-500, 200),
                                          sameStrand = F,
                                          level = "transcript")


enh_vec_region_annot <-as.data.frame(enh_vec_region_ChIPseeker@anno)

enh_vec_region = enh_vec_region %>%
  cbind(enh_vec_region_annot$annotation)


# Load necessary libraries
library(dplyr)
library(ggplot2)

# Sample dataframe: consclust_total_SOM

# Create a cleaned 'annotation_clean' column by extracting only relevant categories
enh_vec_region <- enh_vec_region %>%
  mutate(annotation_clean = case_when(
    grepl("^Exon", enh_vec_region_annot$annotation) ~ "Exon",
    grepl("^Intron", enh_vec_region_annot$annotation) ~ "Intron",
    grepl("^Promoter", enh_vec_region_annot$annotation) ~ "Promoter",
    grepl("^3' UTR", enh_vec_region_annot$annotation) ~ "3' UTR",
    grepl("^5' UTR", enh_vec_region_annot$annotation) ~ "5' UTR",
    grepl("^Distal Intergenic", enh_vec_region_annot$annotation) ~ "Distal Intergenic",
    TRUE ~ NA_character_
  )) %>%
  select(-"enh_vec_region_annot$annotation")




# Summarize the data by SOM and annotation category
summary_data <- enh_vec_region %>%
  group_by(SOM, annotation_clean) %>%
  summarise(count = n()) %>%
  ungroup() %>%
  group_by(SOM) %>%
  mutate(frequency = count / sum(count)) %>%
  ungroup()


# Plot the normalized barplot
ggplot(summary_data, aes(x = factor(SOM), y = frequency, fill = annotation_clean)) + # you can change count by frequency
  geom_bar(stat = "identity", position = "stack") +  # Stack bars for proportions
  labs(x = "SOM", y = "Frequency", fill = "Annotation") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +  # Rotate x-axis labels if necessary
  ggtitle("Annotation of SOM classes. Enhancers")

```


