---
title: "enhancers"
format: html
editor: visual
---

February 2025

## Enhancer calling

I use quickenhancers function from CAGEfightR package because CAGEr's function for enhancer calling does not work. I used the cager object generated by CAGEr to which I had to add seqlength (chromosome length), as required by quickenhancers. I tried quickenhancers from different stages of analysis (CAGEexp from CTSS, consensus cluster, low or high TPM threshold) and I always get the same result on called enhancers. quickenhancers gives ranges of enhancers and raw counts mapping at each enhancers, I use these ranges to extract the normalised counts from my CAGEexp for calling introns (low tpm threshold)

```{r}
# from CAGEconsprom scripts
# saveRDS(tmp_2, "/Users/egomezma/Desktop/cellcycle/R/splitted_scripts/1_CAGEconsprom/ce_canChr.rds")
# saveRDS(newCAGE_cchr_samples_filt, "/Users/egomezma/Desktop/cellcycle/R/splitted_scripts/1_CAGEconsprom/newCAGE_cchr_samples_filt.rds")
# saveRDS(newCAGE_mergRep, "/Users/egomezma/Desktop/cellcycle/R/splitted_scripts/1_CAGEconsprom/newCAGE_unnorm.rds")
# saveRDS(CTSS_norm, "/Users/egomezma/Desktop/cellcycle/R/splitted_scripts/1_CAGEconsprom/CTSS_norm.rds")
# saveRDS(CTSS_cluster, "/Users/egomezma/Desktop/cellcycle/R/splitted_scripts/1_CAGEconsprom/newCAGE_CTSS_promwidth.rds")
# saveRDS(cons_cluster, "/Users/egomezma/Desktop/cellcycle/R/splitted_scripts/1_CAGEconsprom/newCAGE_consclust_5tpm.rds")

# from promoters script
# saveRDS(totalSOM_consclusterGR_df, "/Users/egomezma/Desktop/cellcycle/R/splitted_scripts/2_promoters/totalSOM_consclusterGR_df.rds")
# saveRDS(nuclearSOM_consclusterGR_df, "/Users/egomezma/Desktop/cellcycle/R/splitted_scripts/2_promoters/nuclearSOM_consclusterGR_df.rds")
# saveRDS(fractionSOM_consclusterGR_df, "/Users/egomezma/Desktop/cellcycle/R/splitted_scripts/2_promoters/fractionSOM_consclusterGR_df.rds")


# from introns script
# saveRDS(cluster_lowthr_prom, "/Users/egomezma/Desktop/cellcycle/R/splitted_scripts/3_introns/cluster_lowthr_prom.rds")
# saveRDS(transcript_data, file = "~/Desktop/cellcycle/R/splitted_scripts/3_introns/transcript_data.rds")
# saveRDS(intronID_tsl1, "/Users/egomezma/Desktop/cellcycle/R/splitted_scripts/3_introns/intronID_tsl1.rds")
# saveRDS(tM_intronSignal_good_unique, "~/Desktop/cellcycle/R/splitted_scripts/3_introns/tM_intronSignal_good_unique.rds")
# saveRDS(M_intronSignal_prom_ensembl, "~/Desktop/cellcycle/R/splitted_scripts/3_introns/M_intronSignal_prom_ensembl.rds")

# from enhancers script
# saveRDS(enh, "~/Desktop/cellcycle/R/splitted_scripts/4_enhancers/enh.rds")
# saveRDS(enh_tpm, "~/Desktop/cellcycle/R/splitted_scripts/4_enhancers/enh_tpm.rds")
# saveRDS(enh_tpm, "~/Desktop/cellcycle/R/splitted_scripts/4_enhancers/enh_tpm_overlap.rds")
# saveRDS(enh_bothstr_ranges_df, "~/Desktop/cellcycle/R/splitted_scripts/4_enhancers/enh_bothstr_ranges_df.rds")
# saveRDS(enh_strongF, "~/Desktop/cellcycle/R/splitted_scripts/4_enhancers/enh_strongF.rds")
# saveDb(txdb.ensembl, file = "~/Desktop/cellcycle/R/splitted_scripts/4_enhancers/txdb.ensembl.db")
# saveRDS(enh_stronF_wo_nM, file = "~/Desktop/cellcycle/R/splitted_scripts/4_enhancers/enh_noTSS/enh_stronF_wo_nM.rds")
# saveRDS(enh_stronF_noTSS, "~/Desktop/cellcycle/R/splitted_scripts/4_enhancers/enh_noTSS/enh_stronF_noTSS.rds")


enh_tpm = readRDS("~/Desktop/cellcycle/R/splitted_scripts/4_enhancers/enh_tpm_overlap.rds")
enh_strongF = readRDS("~/Desktop/cellcycle/R/splitted_scripts/4_enhancers/enh_strongF.rds")
txdb.ensembl = loadDb("~/Desktop/cellcycle/R/splitted_scripts/4_enhancers/txdb.ensembl.db")

# saveRDS(enh_stronF_noprom, "~/Desktop/cellcycle/R/splitted_scripts/4_enhancers/enh_noProm/enh_stronF_noprom.rds")
# saveRDS(enh_stronF_noprom_SOM, file = "~/Desktop/cellcycle/R/splitted_scripts/4_enhancers/enh_noProm/enh_stronF_noprom_SOM.rds")
# saveRDS(enh_stronF_wo_nM, file = "~/Desktop/cellcycle/R/splitted_scripts/4_enhancers/enh_noProm/enh_stronF_wo_nM.rds")


```

```{r}

library(BSgenome.Hsapiens.UCSC.hg38)
library(plyranges)
library(CAGEr)
library(tidyr)
library(dplyr)
library(ggplot2)
library(tidyverse)

```



## Filter Promoters chipseeker

```{r}
# Filter out detected enhancers overlapping promoters

# CREATE ENSEMBL TXDB
library(TxDb.Hsapiens.UCSC.hg38.knownGene)
txdb<-TxDb.Hsapiens.UCSC.hg38.knownGene
txdb.ensembl = txdbmaker::makeTxDbFromGFF(file = "~/Desktop/reference_genome/ENSEMBL/Homo_sapiens.GRCh38.113.gtf",format = "gtf",
                               dataSource = "https://ftp.ensembl.org/pub/release-113/gtf/homo_sapiens/",
                               organism = "Homo sapiens")
#seqlevels(txdb.ensembl) is 1, 2 (instead of chr1, chr2). Here is how I changed it and removed non canonical chr
newSeqNames <- paste('chr', seqlevels(txdb.ensembl), sep = '')
names(newSeqNames) <- seqlevels(txdb.ensembl)
txdb.ensembl <- renameSeqlevels(txdb.ensembl, newSeqNames)
keepSeqlevels(x = txdb.ensembl,value = seqlevels(txdb.ensembl)[1:24]) # keep canonical chromosomes
seqlevels(txdb.ensembl) # to check sequence levels
# # 
# saveRDS(txdb.ensembl, file = "~/Desktop/cellcycle/R/splitted_scripts/4_enhancers/txdb.ensembl.rds")
# txdb.ensembl = readRDS("~/Desktop/cellcycle/R/splitted_scripts/4_enhancers/txdb.ensembl.rds")

library(ChIPseeker)


# annotate filterd enhancers
enh_strongF_GR = GRanges(seqnames = enh_strongF$seqnames,
                     ranges = IRanges(start = enh_strongF$start,
                                      end = enh_strongF$end), 
                                      strand = enh_strongF$strand)

annotated_enh_strongF = annotatePeak(enh_strongF_GR, 
                                   TxDb = txdb.ensembl, 
                                   tssRegion = c(-500, 200))
annotated_enh_strongF_df = as.data.frame(annotated_enh_strongF@anno)

enh_strongF = enh_strongF %>%
  mutate(distanceToTSS = annotated_enh_strongF_df$distanceToTSS,
         annotation = annotated_enh_strongF_df$annotation,
         geneStrand = annotated_enh_strongF_df$geneStrand,
         geneId = annotated_enh_strongF_df$geneId)

enh_stronF_noprom = enh_strongF %>%
  filter(!annotation == "Promoter")

# saveRDS(enh_stronF_noprom, "~/Desktop/cellcycle/R/splitted_scripts/4_enhancers/enh_noProm/enh_stronF_noprom.rds")

```

```{r}


#correlation distance to promoter vs sum/nsamples

# enh_tpm
# enh_strongF


# df_tmp = enh_tpm %>%
#   mutate(distanceToTSS = ifelse(distanceToTSS == 0, 0.1, distanceToTSS),
#          overlaps = ifelse(overlap_encode_prom == T, "prom", overlap_encode_enhancers),
#          overlaps = ifelse(overlaps == T, "enh", overlaps),
#          overlaps = ifelse(overlaps == "prom" & overlap_encode_enhancers == T, "prom_enh", overlaps),
#          median_nuc = ifelse(is.na(median_nuc), 1e-3, median_nuc),
#          median_tot = ifelse(is.na(median_tot), 1e-3, median_tot))
#df_tmp$overlaps = as.factor(df_tmp$overlaps)



library(ggplot2)

# enh_stronF_noTSS
# enh_strongF

df_tmp = enh_stronF_noprom %>%
  mutate(distanceToTSS = ifelse(distanceToTSS == 0, 0.1, distanceToTSS),
         median_nuc = ifelse(is.na(median_nuc), 1e-3, median_nuc),
         median_tot = ifelse(is.na(median_tot), 1e-3, median_tot),
         median_nuc = ifelse(median_nuc == 0, 1e-3, median_nuc),
         median_tot = ifelse(median_tot == 0, 1e-3, median_tot))

# df_tmp_enh = df_tmp[which(df_tmp$overlaps == "enh"),]
# df_tmp_prom = df_tmp[which(df_tmp$overlaps == "prom"),]
# df_tmp_promenh = df_tmp[which(df_tmp$overlaps == "prom_enh"),]
# df_tmp_F = df_tmp[which(df_tmp$overlaps == "FALSE"),]

df_tmp_F = df_tmp[which(df_tmp$overlap_encode_enhancers == "FALSE"),]
df_tmp_T = df_tmp[which(df_tmp$overlap_encode_enhancers == "TRUE"),]



p7 = ggplot(df_tmp_F, aes(x = abs(distanceToTSS), y = median_nuc)) +
  geom_bin2d(bins = 60) +  # Uses rectangular bins instead of contours
  scale_x_log10(limits = c(1e-2, 1e+6)) +  
  scale_y_log10(limits = c(1e-4, 1e+3)) +  
  scale_fill_viridis_c() +  # Gradient color for density
  labs(title = "Non overlapping ensembl-enhancers",
       x = "Distance to TSS (log10, absolute)",
       y = "NuclearSum/nSamples Signal (log10)") +
  theme_minimal()
p8 = ggplot(df_tmp_F, aes(x = abs(distanceToTSS), y = median_tot)) +
  geom_bin2d(bins = 60) +  # Uses rectangular bins instead of contours
  scale_x_log10(limits = c(1e-2, 1e+6)) +  
  scale_y_log10(limits = c(1e-4, 1e+3)) +  
  scale_fill_viridis_c() +  # Gradient color for density
  labs(title = "Non overlapping ensembl-enhancers",
       x = "Distance to TSS (log10, absolute)",
       y = "TotalSum/nSamples Signal (log10)") +
  theme_minimal()



```

## HEATMAP

```{r}
library(ComplexHeatmap)
library(circlize)


# enh_stronF_noprom


# Select only the first 5 columns with enhancer expression scores
heatmap_data <- enh_stronF_noprom[, 6:10]

# Apply log10 transformation (adding a small pseudo-count to avoid log(0) issues)
heatmap_data_log <- log10(heatmap_data + 1e-4)  # Small pseudo-count to avoid -Inf

# Define color mapping: blue for low, white for medium, red for high expression
col_fun <- colorRamp2(c(min(heatmap_data_log), 0, max(heatmap_data_log)), c("blue", "white", "red"))

# Create heatmap with hierarchical clustering of rows
p9 = Heatmap(heatmap_data_log,
        name = "Log10(Expression)",  # Legend title
        col = col_fun,  # Color scale
        cluster_rows = TRUE,  # Hierarchical clustering of enhancers
        cluster_columns = FALSE,  # Keep conditions in fixed order
        show_row_names = FALSE,  # Hide enhancer names if too many
        show_column_names = TRUE,  # Show condition names
        row_dend_reorder = TRUE,  # Reorder rows based on hierarchical clustering
        column_title = "Enhancer Expression (Log10) Across Conditions",
        heatmap_legend_param = list(title = "Log10(Relative Expression)"))


```

## SOM

```{r}

library(kohonen)
library(tidyverse)
library(rtracklayer)
library(dplyr)

# enh_stronF_noprom
# enh_stronF_noprom_SOM

## any palette
colors_magma <- viridisLite::magma(9)


get_plot_som_colors <- function(in_mat, xdim, ydim){
  my_palette <- colors_magma
  som_obj <- kohonen::som(in_mat,
                          grid = somgrid(xdim, ydim, topo = "hexagonal"))
  label_unit <- table(som_obj$unit.classif)
  tmp_name <- names(label_unit)
  label_unit <- str_c("Class ", tmp_name, " (", label_unit, ")")
  names(label_unit) <- tmp_name
  tmp_df <- in_mat %>% as.data.frame() %>%
    {cbind(class = som_obj$unit.classif, .)} %>%
    pivot_longer(cols = !class,
                 names_to = "stage",
                 values_to = "value") %>%
    mutate(stage = factor(stage,
                          levels = colnames(in_mat)),
           class = factor(class,
                          levels = str_sort(unique(class), numeric = T)))
  sum_stat <- tmp_df %>% group_by(class, stage) %>%
    summarize(value = mean(value)) %>% ungroup()
  out_plot <- tmp_df%>%
    ggplot(aes(stage, value, fill = stage)) + geom_violin() +
    geom_point(data = sum_stat) +
    geom_line(data = sum_stat, aes(group = class)) +
    facet_wrap(~ class, ncol = xdim, labeller = labeller(class = label_unit),
               scale = "free_y",as.table = F) +
    theme_light() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
    scale_fill_manual(values = my_palette)
  list(som = som_obj,
       stat = sum_stat,
       plot = out_plot)
}




nEnh_matrix = enh_stronF_noprom[,c(1:10)]
# remove rows with value 0 in all columns
nEnh_matrix <- nEnh_matrix[rowSums(nEnh_matrix != 0, na.rm = TRUE) > 0, ]
# scale matrix
nEnh_matrix = t(base::scale(t(nEnh_matrix), center = F, scale = TRUE))

set.seed(23)
plot_som_nEnh = get_plot_som_colors(nEnh_matrix, 5, 5)

enh_stronF_noprom_SOM = enh_stronF_noprom %>% cbind(as.data.frame(plot_som_nEnh$som$unit.classif))
colnames(enh_stronF_noprom_SOM)[28] = "SOM"


# saveRDS(enh_stronF_noprom_SOM, file = "~/Desktop/cellcycle/R/splitted_scripts/4_enhancers/enh_noProm/enh_stronF_noprom_SOM.rds")
```

```{r}

# repeat SOM without nM sample

enh_stronF_wo_nM = enh_stronF_noprom[-5]
# remove rows with value 0 in all columns
enh_stronF_wo_nM = enh_stronF_wo_nM[rowSums(enh_stronF_wo_nM[, 1:9]) != 0, ]

nEnh_matrix = enh_stronF_wo_nM[,c(1:9)]
# remove rows with value 0 in all columns
nEnh_matrix <- nEnh_matrix[rowSums(nEnh_matrix != 0, na.rm = TRUE) > 0, ]
# scale matrix
nEnh_matrix = t(base::scale(t(nEnh_matrix), center = F, scale = TRUE))

set.seed(23)
plot_som_nEnh = get_plot_som_colors(nEnh_matrix, 5, 5)

enh_stronF_wo_nM = enh_stronF_wo_nM %>% cbind(as.data.frame(plot_som_nEnh$som$unit.classif))
colnames(enh_stronF_wo_nM)[28] = "SOM"

# saveRDS(enh_stronF_wo_nM, file = "~/Desktop/cellcycle/R/splitted_scripts/4_enhancers/enh_noProm/enh_stronF_wo_nM.rds")



```



## Export SOM tracks bed


export bed per SOM class
```{r}
# extract bed files per SOM class

# Get unique values in the SOM column
som_classes <- unique(enh_stronF_wo_nM$SOM)

# Loop through each unique SOM class
for (som_class in som_classes) {
  # Filter rows belonging to the current SOM class
  bed_data <- enh_stronF_wo_nM[enh_stronF_wo_nM$SOM == som_class, c("seqnames", "start", "end", "strand")]
  
  # Define the output file name
  bed_file <- paste0("~/Desktop/cellcycle/plots/ELENA_CAGE_mergedRep/enhancers/strong_filter_noprom/strong_filter_noprom_nM/BED/SOM_bed/class", som_class, ".bed")
  
  # Write to a BED file (without row names and quotes)
  write.table(bed_data, file = bed_file, sep = "\t", quote = FALSE, row.names = FALSE, col.names = FALSE)
}


```


Export on bed all SOM classes with numer
```{r}
# extract in a single bed file all SOM to visualise in IGV SOM classes by numbers

# Define the output file
bed_file <- "~/Desktop/cellcycle/plots/ELENA_CAGE_mergedRep/enhancers/strong_filter_noprom/strong_filter_noprom_nM/BED/SOM_bed/all_classes.bed"

# Select relevant columns and include SOM for coloring
bed_data <- enh_stronF_wo_nM[, c("seqnames", "start", "end", "SOM")]

# Write to a single BED file
write.table(bed_data, file = bed_file, sep = "\t", quote = FALSE, row.names = FALSE, col.names = FALSE)
```


Export bed tracks per sample

```{r}

# Loop through sample columns (1 to 10)
for (i in 1:10) {
  sample_name <- colnames(enh_stronF_wo_nM)[i]  # Get sample name
  bed_data <- enh_stronF_wo_nM[enh_stronF_wo_nM[[i]] > 0, c("seqnames", "start", "end", "strand")]  # Filter rows where value > 0
  
  # Define the output file name
  bed_file <- paste0("~/Desktop/cellcycle/plots/ELENA_CAGE_mergedRep/enhancers/strong_filter_noprom/strong_filter_noprom_nM/BED/sample_bed/", sample_name, ".bed")

  # Write to a BED file (without row names and quotes)
  write.table(bed_data, file = bed_file, sep = "\t", quote = FALSE, row.names = FALSE, col.names = FALSE)
}

```



## GO loop

```{r}

library(ggplot2)
library(clusterProfiler)

# Get unique SOM values
som_classes <- unique(enh_stronF_wo_nM$SOM)

# Directory to save results
output_dir <- "~/Desktop/cellcycle/plots/ELENA_CAGE_mergedRep/enhancers/strong_filter_noprom/strong_filter_noprom_nM/GO/"

# Loop through each unique SOM class
for (som_class in som_classes) {
  # Filter rows for the current SOM class
  eclass <- enh_stronF_wo_nM[enh_stronF_wo_nM$SOM == som_class, ]

  # Convert gene IDs
  S.df <- bitr(unique(eclass$geneId),
               fromType = "ENSEMBL",
               toType = "ENTREZID",
               OrgDb = odb)

  # Perform GO enrichment analysis
  S.ego <- enrichGO(gene = S.df$ENTREZID,
                    OrgDb = odb,
                    ont = "BP",
                    pvalueCutoff = 0.05,
                    pAdjustMethod = "BH",
                    qvalueCutoff = 0.1)

  # Generate GO enrichment plot
  num_enhancers <- nrow(eclass)
  S.ego.plot <- S.ego@result %>%
    arrange(p.adjust) %>% 
    head(20) %>%
    mutate(Description = factor(Description, levels = rev(Description))) %>%
    ggplot(aes(x = -log10(p.adjust), 
               y = Description,
               size = Count,
               colour = -log10(p.adjust))) +
      geom_point() +
      ggtitle(paste("Class", som_class, ";", num_enhancers, "enhancers")) +
      theme_classic() +
      theme(axis.text.y = element_text(size = 11))

  # Select the top 20 enriched GO terms
  top_n_GO <- S.ego@result[1:20, c("ID", "Description", "geneID")]

  # FUNCTION: Convert genes
  convert_genes <- function(gene_ids, from_type, to_type, orgdb) {
    bitr(gene_ids, fromType = from_type, toType = to_type, OrgDb = orgdb)
  }

  # Split geneIDs and convert to gene SYMBOLS
  GO_list <- lapply(top_n_GO$geneID, function(genes) {
    gene_vec <- unlist(strsplit(genes, "/"))  # Split by "/"
    converted <- convert_genes(gene_vec, "ENTREZID", "SYMBOL", odb)
    return(converted$SYMBOL)
  })

  # Find max number of genes in any category
  max_length <- max(sapply(GO_list, length))

  # Create a data frame with correct column names
  GO_df <- as.data.frame(do.call(cbind, lapply(GO_list, function(genes) c(genes, rep(NA, max_length - length(genes))))))
  colnames(GO_df) <- top_n_GO$Description  # Set correct column names

  # Define file paths
  table_path <- paste0(output_dir, "class", som_class, ".csv")
  plot_path <- paste0(output_dir, "class", som_class, ".png")

  # Save table
  write.table(GO_df, file = table_path, quote = FALSE, col.names = TRUE, row.names = FALSE, sep = "\t")

  # Save plot
  ggsave(plot_path, S.ego.plot, width = 9, height = 6)
}




```



## SOM TPM

```{r}
#enh_stronF_wo_nM

ggplot(enh_stronF_wo_nM, aes(x = factor(SOM), y = median_tot, fill = factor(SOM))) +
  geom_violin(trim = FALSE, alpha = 0.7) +        # Semi-transparent violin plot
  geom_jitter(width = 0.2, size = 0.1, alpha = 0.2) + # Jitter for individual points
  labs(x = "SOM", y = "Median of total signal (log10 scaled TPM)", fill = "Annotation") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) + # Rotate x-axis labels if needed
  ggtitle("Enhancer TPM of SOM Classes.") +
  scale_y_log10(limits = c(1e-3, 1e2),
                breaks = c(1e-3, 1e-2, 1e-1, 1, 1e1, 1e2)) # Set log10 scale


```


## enhancers vecinity

```{r}

# enh_stronF_wo_nM



# Sort the dataframe by genomic coordinates
enh_stronF_wo_nM_sorted <- enh_stronF_wo_nM[order(enh_stronF_wo_nM$seqnames, enh_stronF_wo_nM$start, enh_stronF_wo_nM$end), ]

# Define shift function
shift_column <- function(vec, shift) {
  if (shift > 0) {
    return(c(rep(NA, shift), vec[1:(length(vec) - shift)]))  # Down shift
  } else if (shift < 0) {
    return(c(vec[(abs(shift) + 1):length(vec)], rep(NA, abs(shift))))  # Up shift
  } else {
    return(vec)  # No shift
  }
}


# Create new columns
for (i in c(5,4,3,2,1,-1,-2,-3,-4,-5)) {
  enh_stronF_wo_nM_sorted[[as.character(i)]] <- shift_column(enh_stronF_wo_nM_sorted$SOM, i)
}

colnames(enh_stronF_wo_nM_sorted)[29:38] <- c("-5", "-4", "-3", "-2", "-1", "1", "2", "3", "4", "5")




# Add a new column "repetition" that counts occurrences of the SOM value in columns 28:37
enh_stronF_wo_nM_sorted$repetition <- rowSums(enh_stronF_wo_nM_sorted[, 28:37] == enh_stronF_wo_nM_sorted$SOM, na.rm = TRUE)

# add columns called SOM1 to SOM25 and print the proportion of each enhancer class for each row
enh_vecinity = enh_stronF_wo_nM_sorted

for (i in 1:25) {
  col_name <- paste0("SOM", i)  # Generate column name
  enh_vecinity[[col_name]] <- ifelse(rowSums(enh_vecinity[, 28:37] == i, na.rm = TRUE) == 0, 
                                                 0, 
                                                 rowSums(enh_vecinity[, 28:37] == i, na.rm = TRUE) / 10)
}

```


```{r}

### PLOT VIOLIN
# Load required library
library(ggplot2)
library(reshape2)  # For data transformation

# Convert SOM1 to SOM25 from wide to long format

df_long <- enh_vecinity %>%
  pivot_longer(cols = 39:63,    # Specify the columns to pivot
               names_to = "SOM_violin", # The name of the new column for variable names
               values_to = "Value") # The name of the new column for the values

# Convert 'SOM_violin' to a factor to preserve the original order
df_long$SOM_violin <- factor(df_long$SOM_violin, levels = unique(df_long$SOM_violin))

# Create the violin plot
ggplot(df_long, aes(x = SOM_violin, y = Value)) +
  geom_violin(fill = "steelblue", alpha = 0.7) +  # Violin plot
  geom_jitter(width = 0.2, alpha = 0.4, color = "black") +  # Add jittered points for visibility
  theme_minimal() +
  labs(title = "Distribution of Proportions for SOM1 to SOM25",
       x = "SOM Class",
       y = "Proportion") +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) # Rotate x-axis labels


```



<!-- ```{r} -->
<!-- enh_vecinity_c1 = enh_vecinity[which(enh_vecinity$SOM == 1), ] -->
<!-- enh_vecinity_c1 = enh_vecinity_c1[39:63] -->
<!-- enh_vecinity_c1 = enh_vecinity_c1 %>% colSums() -->
<!-- df_counts <- enh_vecinity %>% -->
<!--   group_by(SOM) %>% -->
<!--   summarise(repetition = n()) %>% -->
<!--   ungroup() -->
<!-- enh_vecinity_c1 = enh_vecinity_c1 %>% cbind(df_counts) -->
<!-- enh_vecinity_c1 = enh_vecinity_c1 %>% mutate(class_freq = repetition / sum(repetition), -->
<!--                                              somFreq_norm = . / class_freq) -->
<!-- hist_vecino = ggplot(enh_vecinity_c1, aes(x=SOM, y=somFreq_norm)) +  -->
<!--   geom_bar(stat="identity") + -->
<!--   labs(title = "Class 5. Frequency of neighbouring classes of enhancers", -->
<!--        x = "SOM classes", -->
<!--        y = "Normalised frequency") -->

<!-- enh_vecinity_c5 = enh_vecinity[which(enh_vecinity$SOM == 5), ] -->
<!-- enh_vecinity_c5 = enh_vecinity_c5[39:63] -->
<!-- enh_vecinity_c5 = enh_vecinity_c5 %>% colSums() -->
<!-- enh_vecinity_c5 = enh_vecinity_c5 %>% cbind(df_counts) -->
<!-- enh_vecinity_c5 = enh_vecinity_c5 %>% mutate(class_freq = repetition / sum(repetition), -->
<!--                                              somFreq_norm = . / class_freq) -->





<!-- df_counts <- enh_vecinity %>% -->
<!--   group_by(SOM) %>% -->
<!--   summarise(repetition = n()) %>% -->
<!--   ungroup() %>% -->
<!--   mutate(class_freq = repetition / sum(repetition)) -->


<!-- enh_vecinity_c1 = enh_vecinity[which(enh_vecinity$SOM == 1), ] -->
<!-- enh_vecinity_c1 = enh_vecinity_c1[39:63] -->
<!-- enh_vecinity_c1 = enh_vecinity_c1 %>% colMeans() -->
<!-- enh_vecinity_c1 = enh_vecinity_c1 %>% cbind(df_counts) -->
<!-- enh_vecinity_c1 = enh_vecinity_c1 %>% mutate(class_freq = repetition / sum(repetition), -->
<!--                                              somFreq_norm = . * class_freq, -->
<!--                                              ratio = ./class_freq -1) -->
<!-- hist_vecino1 = ggplot(enh_vecinity_c1, aes(x = factor(SOM, levels = 1:25), y = ratio)) +  -->
<!--   geom_bar(stat = "identity") + -->
<!--   scale_y_continuous(limits = c(-0.5, 0.5)) + -->
<!--   scale_x_discrete(breaks = 1:25) +  # Ensure all categories from 1 to 25 appear -->
<!--   labs(title = "Class 1. Frequency of Neighbouring Classes of Enhancers", -->
<!--        x = "SOM Classes", -->
<!--        y = "Normalized Frequency") + -->
<!--   theme_minimal() + -->
<!--   theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1))  # Rotate labels for readability -->



<!-- enh_vecinity_c5 = enh_vecinity[which(enh_vecinity$SOM == 5), ] -->
<!-- enh_vecinity_c5 = enh_vecinity_c5[39:63] -->
<!-- enh_vecinity_c5 = enh_vecinity_c5 %>% colMeans() -->
<!-- enh_vecinity_c5 = enh_vecinity_c5 %>% cbind(df_counts) -->
<!-- enh_vecinity_c5 = enh_vecinity_c5 %>% mutate(class_freq = repetition / sum(repetition), -->
<!--                                              somFreq_norm = . * class_freq, -->
<!--                                              ratio = ./class_freq -1) -->
<!-- hist_vecino5 = ggplot(enh_vecinity_c5, aes(x = factor(SOM, levels = 1:25), y = ratio)) +  -->
<!--   geom_bar(stat = "identity") + -->
<!--   scale_y_continuous(limits = c(-0.5, 0.5)) + -->
<!--   scale_x_discrete(breaks = 1:25) +  # Ensure all categories from 1 to 25 appear -->
<!--   labs(title = "Class 5. Frequency of Neighbouring Classes of Enhancers", -->
<!--        x = "SOM Classes", -->
<!--        y = "Normalized Frequency") + -->
<!--   theme_minimal() + -->
<!--   theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1))  # Rotate labels for readability -->

<!-- # Print the plot -->
<!-- print(hist_vecino5) -->
<!-- ``` -->



```{r}

output_dir <- "~/Desktop/cellcycle/plots/ELENA_CAGE_mergedRep/enhancers/strong_filter_noprom/strong_filter_noprom_nM/neighbour"
# Get unique SOM classes
som_classes <- sort(unique(enh_vecinity$SOM))

# Loop through each SOM class and generate/save a plot
for (som_class in som_classes) {
  
  # Filter for the current SOM class
  enh_vecinity_c <- enh_vecinity %>% filter(SOM == som_class)
  
  # Extract relevant columns (39:63) and compute column means
  enh_vecinity_c <- colMeans(enh_vecinity_c[, 39:63], na.rm = TRUE) %>% as.data.frame()
  colnames(enh_vecinity_c) <- "value"
  
  # Add SOM numbers and repetition counts
  enh_vecinity_c$SOM <- 1:25  # Ensure all SOM values from 1 to 25 are included
  enh_vecinity_c <- left_join(enh_vecinity_c, df_counts, by = "SOM") 
  
  # Compute normalized ratios
  enh_vecinity_c <- enh_vecinity_c %>% 
    mutate(class_freq = repetition / sum(repetition),
           somFreq_norm = value * class_freq,
           ratio = value / class_freq - 1)

  # Create the plot
  hist_vecino <- ggplot(enh_vecinity_c, aes(x = factor(SOM, levels = 1:25), y = ratio)) + 
    geom_bar(stat = "identity") +
    scale_y_continuous(limits = c(-0.5, 0.5)) +
    scale_x_discrete(breaks = 1:25) +  # Ensure all categories appear
    labs(title = paste("Class", som_class, "- Frequency of Neighbouring Classes of Enhancers"),
         x = "SOM Classes",
         y = "Normalized Frequency") +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1))

  # Save the plot as PNG
  ggsave(filename = paste0(output_dir, "/hist_vecino_", som_class, ".png"), 
         plot = hist_vecino, width = 8, height = 6, dpi = 300)
}

  
```

```{r}

enh_vec_region = enh_stronF_wo_nM
library(GenomicRanges)
library(rtracklayer)
library(BSgenome.Hsapiens.UCSC.hg38)





# Convert to GenomicRanges object
enh_vec_region_gr <- GRanges(seqnames = enh_vec_region$seqnames,
                     ranges = IRanges(start = enh_vec_region$start, end = enh_vec_region$end),
                     strand = enh_vec_region$strand)
# Assign actual chromosome lengths
seqlengths(enh_vec_region_gr) <- seqlengths(BSgenome.Hsapiens.UCSC.hg38)[seqlevels(enh_vec_region_gr)]

# Find clusters of enhancers within 500kb 
clusters <- GenomicRanges::reduce(enh_vec_region_gr, min.gapwidth = 500000) 

# Assign cluster IDs
enh_vec_region$cluster <- findOverlaps(enh_vec_region_gr, clusters)@to

# Check clustered vs. isolated enhancers
# table(bed$cluster)





cluster_counts <- enh_vec_region %>%
    count(cluster)

n_distribution <- cluster_counts %>%
  count(n)  # 'n' is how many times a cluster appears, second count() gives frequency

# Plot histogram
distrib = ggplot(n_distribution, aes(x = n, y = nn)) + 
  geom_bar(stat = "identity", fill = "steelblue") +
  labs(title = "Distribution of cluster sizes",
       x = "Cluster size",
       y = "Number of clusters") +
  theme_minimal()

cluster_counts <- cluster_counts %>%
  mutate(enh_size = case_when(
    n == 1 ~ "single",        # Appears once
    n >= 2 & n <= 5 ~ "small", # Appears 2-5 times
    n > 5 & n <= 24 ~ "big"    # Appears 6-24 times
  ))


# cluster_counts <- cluster_counts %>%
#   mutate(enh_size = case_when(
#     n == 1 ~ "single",        # Appears once
#     n == 2 ~ "small", # Appears 2-5 times
#     n > 2 ~ "big"    # Appears 6-24 times
#   ))

# Merge classification back into enh_vec_region
enh_vec_region <- enh_vec_region %>%
  left_join(cluster_counts, by = "cluster")  # Adds the enh_size column



df_counts <- enh_vecinity %>%
  group_by(SOM) %>%
  summarise(repetition = n()) %>%
  ungroup() %>%
  mutate(class_freq = repetition / sum(repetition))


enh_vec_region_single = enh_vec_region[which(enh_vec_region$enh_size == "single"),]

count_single <- enh_vec_region_single %>%
  count(SOM) %>%
  complete(SOM = 1:25, fill = list(n = 0)) %>% # Ensures all SOMs exist, fills missing ones with n = 0
  cbind(df_counts)
count_single = count_single[-3]
count_single = count_single %>%
  mutate(freq = n*class_freq) %>%
  mutate(freq_single = n / sum(n))



enh_vec_region_small = enh_vec_region[which(enh_vec_region$enh_size == "small"),]

count_small <- enh_vec_region_small %>%
  count(SOM) %>%
  complete(SOM = 1:25, fill = list(n = 0)) %>% # Ensures all SOMs exist, fills missing ones with n = 0
  cbind(df_counts)
count_small = count_small[-3]
count_small = count_small %>%
  mutate(freq = n*class_freq) %>%
  mutate(freq_small = n / sum(n))


enh_vec_region_big = enh_vec_region[which(enh_vec_region$enh_size == "big"),]

count_big <- enh_vec_region_big %>%
  count(SOM) %>%
  complete(SOM = 1:25, fill = list(n = 0)) %>% # Ensures all SOMs exist, fills missing ones with n = 0
  cbind(df_counts)
count_big = count_big[-3]
count_big = count_big %>%
  mutate(freq = n*class_freq) %>%
  mutate(freq_big = n / sum(n))


library(ggrepel)
ggplot(count_single, aes(x = freq_single, y = class_freq, label = SOM)) +
  geom_point(color = "steelblue", alpha = 0.7, size = 2) +  # Smaller dots
  geom_text_repel(size = 3, box.padding = 0.3, point.padding = 0.2) +  # Repelled labels
  geom_abline(slope = 1, intercept = 0, color = "black", linetype = "dashed", size = 0.5) +  # Fine x=y line
  scale_x_continuous(limits = c(0, 0.35)) +  # Set x-axis limit
  scale_y_continuous(limits = c(0, 0.35)) +  # Set y-axis limit
  labs(title = "Correlation between enhancer classes",
       x = "SOM Class Frequency of Isolated Enhancers",
       y = "SOM Class Frequency of All Enhancers") +
  theme_minimal()
```

## BED clusters

```{r}

enh_vec_region <- enh_vec_region %>%
  group_by(cluster) %>% 
  mutate(cluster_start = first(start),  # First 'start' for each group
         cluster_end = last(end)) %>%      # Last 'end' for each group
  ungroup()

bed_clusters = enh_vec_region %>% dplyr::select(12,32,33,31) %>%
  unique()


# Define the output file
bed_file <- "~/Desktop/cellcycle/plots/ELENA_CAGE_mergedRep/enhancers/strong_filter_noprom/strong_filter_noprom_nM/BED/enh_clusters_500kb.bed"


# Write to a single BED file
write.table(bed_clusters, file = bed_file, sep = "\t", quote = FALSE, row.names = FALSE, col.names = FALSE)

```

Color enhancer clusters in bed file according to size
```{r}

library(dplyr)

# Example cluster-to-color mapping
cluster_colors <- c(
  "single" = "255,0,0",    # red
  "small" = "0,255,0",    # green
  "big" = "0,0,255"     # blue
)

# Prepare BED12-style or wide BED data
widebed_clusters <- bed_clusters %>%
  mutate(
    name = enh_size,                  # or any unique identifier
    score = 0,                       # default score
    strand = ".",                    # or "+" / "-" if known
    thickStart = cluster_start,        # equal to chromStart
    thickEnd = cluster_end,            # equal to chromEnd
    itemRgb = cluster_colors[enh_size]
  ) %>%
  select(seqnames, cluster_start, cluster_end, name, score, strand,
         thickStart, thickEnd, itemRgb)

# Optional: write to file
write.table(widebed_clusters, "~/Desktop/cellcycle/plots/ELENA_CAGE_mergedRep/enhancers/strong_filter_noprom/strong_filter_noprom_nM/BED/SOM_bed/colored_enhClusters.bed", sep="\t", quote=FALSE, row.names=FALSE, col.names=FALSE)



```





## annot SOM enhancers

```{r}


enh_vec_region_gr <- GRanges(seqnames = enh_vec_region$seqnames,
                     ranges = IRanges(start = enh_vec_region$start, end = enh_vec_region$end),
                     strand = enh_vec_region$strand,
                     SOM = enh_vec_region$SOM)

enh_vec_region_ChIPseeker <- annotatePeak(enh_vec_region_gr,
                                          TxDb = txdb.ensembl,
                                          tssRegion = c(-500, 200),
                                          sameStrand = F,
                                          level = "transcript")


enh_vec_region_annot <-as.data.frame(enh_vec_region_ChIPseeker@anno)

enh_vec_region = enh_vec_region %>%
  cbind(enh_vec_region_annot$annotation)


# Load necessary libraries
library(dplyr)
library(ggplot2)

# Sample dataframe: consclust_total_SOM

# Create a cleaned 'annotation_clean' column by extracting only relevant categories
enh_vec_region <- enh_vec_region %>%
  mutate(annotation_clean = case_when(
    grepl("^Exon", enh_vec_region_annot$annotation) ~ "Exon",
    grepl("^Intron", enh_vec_region_annot$annotation) ~ "Intron",
    grepl("^Promoter", enh_vec_region_annot$annotation) ~ "Promoter",
    grepl("^3' UTR", enh_vec_region_annot$annotation) ~ "3' UTR",
    grepl("^5' UTR", enh_vec_region_annot$annotation) ~ "5' UTR",
    grepl("^Distal Intergenic", enh_vec_region_annot$annotation) ~ "Distal Intergenic",
    TRUE ~ NA_character_
  )) %>%
  select(-"enh_vec_region_annot$annotation")




# Summarize the data by SOM and annotation category
summary_data <- enh_vec_region %>%
  group_by(SOM, annotation_clean) %>%
  summarise(count = n()) %>%
  ungroup() %>%
  group_by(SOM) %>%
  mutate(frequency = count / sum(count)) %>%
  ungroup()


# Plot the normalized barplot
ggplot(summary_data, aes(x = factor(SOM), y = frequency, fill = annotation_clean)) + # you can change count by frequency
  geom_bar(stat = "identity", position = "stack") +  # Stack bars for proportions
  labs(x = "SOM", y = "Frequency", fill = "Annotation") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +  # Rotate x-axis labels if necessary
  ggtitle("Annotation of SOM classes. Enhancers")

```
